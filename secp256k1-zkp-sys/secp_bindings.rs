/* automatically generated by rust-bindgen 0.55.1 */

pub const SECP256K1_FLAGS_TYPE_MASK: u32 = 255;
pub const SECP256K1_FLAGS_TYPE_CONTEXT: u32 = 1;
pub const SECP256K1_FLAGS_TYPE_COMPRESSION: u32 = 2;
pub const SECP256K1_FLAGS_BIT_CONTEXT_VERIFY: u32 = 256;
pub const SECP256K1_FLAGS_BIT_CONTEXT_SIGN: u32 = 512;
pub const SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY: u32 = 1024;
pub const SECP256K1_FLAGS_BIT_COMPRESSION: u32 = 256;
pub const SECP256K1_CONTEXT_VERIFY: u32 = 257;
pub const SECP256K1_CONTEXT_SIGN: u32 = 513;
pub const SECP256K1_CONTEXT_DECLASSIFY: u32 = 1025;
pub const SECP256K1_CONTEXT_NONE: u32 = 1;
pub const SECP256K1_EC_COMPRESSED: u32 = 258;
pub const SECP256K1_EC_UNCOMPRESSED: u32 = 2;
pub const SECP256K1_TAG_PUBKEY_EVEN: u32 = 2;
pub const SECP256K1_TAG_PUBKEY_ODD: u32 = 3;
pub const SECP256K1_TAG_PUBKEY_UNCOMPRESSED: u32 = 4;
pub const SECP256K1_TAG_PUBKEY_HYBRID_EVEN: u32 = 6;
pub const SECP256K1_TAG_PUBKEY_HYBRID_ODD: u32 = 7;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SECP256K1_SURJECTIONPROOF_MAX_N_INPUTS: u32 = 256;
pub const SECP256K1_SURJECTIONPROOF_MAX_USED_INPUTS: u32 = 256;
pub const SECP256K1_WHITELIST_MAX_N_KEYS: u32 = 256;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct secp256k1_zkp_context_struct {
    _unused: [u8; 0],
}
#[doc = " Opaque data structure that holds context information (precomputed tables etc.)."]
#[doc = ""]
#[doc = "  The purpose of context structures is to cache large precomputed data tables"]
#[doc = "  that are expensive to construct, and also to maintain the randomization data"]
#[doc = "  for blinding."]
#[doc = ""]
#[doc = "  Do not create a new context object for each operation, as construction is"]
#[doc = "  far slower than all other API calls (~100 times slower than an ECDSA"]
#[doc = "  verification)."]
#[doc = ""]
#[doc = "  A constructed context can safely be used from multiple threads"]
#[doc = "  simultaneously, but API calls that take a non-const pointer to a context"]
#[doc = "  need exclusive access to it. In particular this is the case for"]
#[doc = "  secp256k1_zkp_context_destroy, secp256k1_zkp_context_preallocated_destroy,"]
#[doc = "  and secp256k1_zkp_context_randomize."]
#[doc = ""]
#[doc = "  Regarding randomization, either do it once at creation time (in which case"]
#[doc = "  you do not need any locking for the other calls), or use a read-write lock."]
pub type secp256k1_zkp_context = secp256k1_zkp_context_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct secp256k1_zkp_scratch_space_struct {
    _unused: [u8; 0],
}
#[doc = " Opaque data structure that holds rewriteable \"scratch space\""]
#[doc = ""]
#[doc = "  The purpose of this structure is to replace dynamic memory allocations,"]
#[doc = "  because we target architectures where this may not be available. It is"]
#[doc = "  essentially a resizable (within specified parameters) block of bytes,"]
#[doc = "  which is initially created either by memory allocation or TODO as a pointer"]
#[doc = "  into some fixed rewritable space."]
#[doc = ""]
#[doc = "  Unlike the context object, this cannot safely be shared between threads"]
#[doc = "  without additional synchronization logic."]
pub type secp256k1_zkp_scratch_space = secp256k1_zkp_scratch_space_struct;
#[doc = " Opaque data structure that holds a parsed and valid public key."]
#[doc = ""]
#[doc = "  The exact representation of data inside is implementation defined and not"]
#[doc = "  guaranteed to be portable between different platforms or versions. It is"]
#[doc = "  however guaranteed to be 64 bytes in size, and can be safely copied/moved."]
#[doc = "  If you need to convert to a format suitable for storage, transmission, or"]
#[doc = "  comparison, use secp256k1_zkp_ec_pubkey_serialize and secp256k1_zkp_ec_pubkey_parse."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct secp256k1_zkp_pubkey {
    pub data: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_secp256k1_zkp_pubkey() {
    assert_eq!(
        ::std::mem::size_of::<secp256k1_zkp_pubkey>(),
        64usize,
        concat!("Size of: ", stringify!(secp256k1_zkp_pubkey))
    );
    assert_eq!(
        ::std::mem::align_of::<secp256k1_zkp_pubkey>(),
        1usize,
        concat!("Alignment of ", stringify!(secp256k1_zkp_pubkey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<secp256k1_zkp_pubkey>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_pubkey),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Opaque data structured that holds a parsed ECDSA signature."]
#[doc = ""]
#[doc = "  The exact representation of data inside is implementation defined and not"]
#[doc = "  guaranteed to be portable between different platforms or versions. It is"]
#[doc = "  however guaranteed to be 64 bytes in size, and can be safely copied/moved."]
#[doc = "  If you need to convert to a format suitable for storage, transmission, or"]
#[doc = "  comparison, use the secp256k1_zkp_ecdsa_signature_serialize_* and"]
#[doc = "  secp256k1_zkp_ecdsa_signature_parse_* functions."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct secp256k1_zkp_ecdsa_signature {
    pub data: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_secp256k1_zkp_ecdsa_signature() {
    assert_eq!(
        ::std::mem::size_of::<secp256k1_zkp_ecdsa_signature>(),
        64usize,
        concat!("Size of: ", stringify!(secp256k1_zkp_ecdsa_signature))
    );
    assert_eq!(
        ::std::mem::align_of::<secp256k1_zkp_ecdsa_signature>(),
        1usize,
        concat!("Alignment of ", stringify!(secp256k1_zkp_ecdsa_signature))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_ecdsa_signature>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_ecdsa_signature),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " A pointer to a function to deterministically generate a nonce."]
#[doc = ""]
#[doc = " Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail."]
#[doc = " Out:     nonce32:   pointer to a 32-byte array to be filled by the function."]
#[doc = " In:      msg32:     the 32-byte message hash being verified (will not be NULL)"]
#[doc = "          key32:     pointer to a 32-byte secret key (will not be NULL)"]
#[doc = "          algo16:    pointer to a 16-byte array describing the signature"]
#[doc = "                     algorithm (will be NULL for ECDSA for compatibility)."]
#[doc = "          data:      Arbitrary data pointer that is passed through."]
#[doc = "          attempt:   how many iterations we have tried to find a nonce."]
#[doc = "                     This will almost always be 0, but different attempt values"]
#[doc = "                     are required to result in a different nonce."]
#[doc = ""]
#[doc = " Except for test cases, this function should compute some cryptographic hash of"]
#[doc = " the message, the algorithm, the key and the attempt."]
pub type secp256k1_zkp_nonce_function = ::std::option::Option<
    unsafe extern "C" fn(
        nonce32: *mut ::std::os::raw::c_uchar,
        msg32: *const ::std::os::raw::c_uchar,
        key32: *const ::std::os::raw::c_uchar,
        algo16: *const ::std::os::raw::c_uchar,
        data: *mut ::std::os::raw::c_void,
        attempt: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub static mut secp256k1_zkp_context_no_precomp: *const secp256k1_zkp_context;
}
extern "C" {
    #[doc = " Create a secp256k1 context object (in dynamically allocated memory)."]
    #[doc = ""]
    #[doc = "  This function uses malloc to allocate memory. It is guaranteed that malloc is"]
    #[doc = "  called at most once for every call of this function. If you need to avoid dynamic"]
    #[doc = "  memory allocation entirely, see the functions in secp256k1_zkp_preallocated.h."]
    #[doc = ""]
    #[doc = "  Returns: a newly created context object."]
    #[doc = "  In:      flags: which parts of the context to initialize."]
    #[doc = ""]
    #[doc = "  See also secp256k1_zkp_context_randomize."]
    pub fn secp256k1_zkp_context_create(
        flags: ::std::os::raw::c_uint,
    ) -> *mut secp256k1_zkp_context;
}
extern "C" {
    #[doc = " Copy a secp256k1 context object (into dynamically allocated memory)."]
    #[doc = ""]
    #[doc = "  This function uses malloc to allocate memory. It is guaranteed that malloc is"]
    #[doc = "  called at most once for every call of this function. If you need to avoid dynamic"]
    #[doc = "  memory allocation entirely, see the functions in secp256k1_zkp_preallocated.h."]
    #[doc = ""]
    #[doc = "  Returns: a newly created context object."]
    #[doc = "  Args:    ctx: an existing context to copy (cannot be NULL)"]
    pub fn secp256k1_zkp_context_clone(
        ctx: *const secp256k1_zkp_context,
    ) -> *mut secp256k1_zkp_context;
}
extern "C" {
    #[doc = " Destroy a secp256k1 context object (created in dynamically allocated memory)."]
    #[doc = ""]
    #[doc = "  The context pointer may not be used afterwards."]
    #[doc = ""]
    #[doc = "  The context to destroy must have been created using secp256k1_zkp_context_create"]
    #[doc = "  or secp256k1_zkp_context_clone. If the context has instead been created using"]
    #[doc = "  secp256k1_zkp_context_preallocated_create or secp256k1_zkp_context_preallocated_clone, the"]
    #[doc = "  behaviour is undefined. In that case, secp256k1_zkp_context_preallocated_destroy must"]
    #[doc = "  be used instead."]
    #[doc = ""]
    #[doc = "  Args:   ctx: an existing context to destroy, constructed using"]
    #[doc = "               secp256k1_zkp_context_create or secp256k1_zkp_context_clone"]
    pub fn secp256k1_zkp_context_destroy(ctx: *mut secp256k1_zkp_context);
}
extern "C" {
    #[doc = " Set a callback function to be called when an illegal argument is passed to"]
    #[doc = "  an API call. It will only trigger for violations that are mentioned"]
    #[doc = "  explicitly in the header."]
    #[doc = ""]
    #[doc = "  The philosophy is that these shouldn't be dealt with through a"]
    #[doc = "  specific return value, as calling code should not have branches to deal with"]
    #[doc = "  the case that this code itself is broken."]
    #[doc = ""]
    #[doc = "  On the other hand, during debug stage, one would want to be informed about"]
    #[doc = "  such mistakes, and the default (crashing) may be inadvisable."]
    #[doc = "  When this callback is triggered, the API function called is guaranteed not"]
    #[doc = "  to cause a crash, though its return value and output arguments are"]
    #[doc = "  undefined."]
    #[doc = ""]
    #[doc = "  When this function has not been called (or called with fn==NULL), then the"]
    #[doc = "  default handler will be used.\u{a0}The library provides a default handler which"]
    #[doc = "  writes the message to stderr and calls abort. This default handler can be"]
    #[doc = "  replaced at link time if the preprocessor macro"]
    #[doc = "  USE_EXTERNAL_DEFAULT_CALLBACKS is defined, which is the case if the build"]
    #[doc = "  has been configured with --enable-external-default-callbacks. Then the"]
    #[doc = "  following two symbols must be provided to link against:"]
    #[doc = "   - void secp256k1_zkp_default_illegal_callback_fn(const char* message, void* data);"]
    #[doc = "   - void secp256k1_zkp_default_error_callback_fn(const char* message, void* data);"]
    #[doc = "  The library can call these default handlers even before a proper callback data"]
    #[doc = "  pointer could have been set using secp256k1_zkp_context_set_illegal_callback or"]
    #[doc = "  secp256k1_zkp_context_set_error_callback, e.g., when the creation of a context"]
    #[doc = "  fails. In this case, the corresponding default handler will be called with"]
    #[doc = "  the data pointer argument set to NULL."]
    #[doc = ""]
    #[doc = "  Args: ctx:  an existing context object (cannot be NULL)"]
    #[doc = "  In:   fun:  a pointer to a function to call when an illegal argument is"]
    #[doc = "              passed to the API, taking a message and an opaque pointer."]
    #[doc = "              (NULL restores the default handler.)"]
    #[doc = "        data: the opaque pointer to pass to fun above."]
    #[doc = ""]
    #[doc = "  See also secp256k1_zkp_context_set_error_callback."]
    pub fn secp256k1_zkp_context_set_illegal_callback(
        ctx: *mut secp256k1_zkp_context,
        fun: ::std::option::Option<
            unsafe extern "C" fn(
                message: *const ::std::os::raw::c_char,
                data: *mut ::std::os::raw::c_void,
            ),
        >,
        data: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Set a callback function to be called when an internal consistency check"]
    #[doc = "  fails. The default is crashing."]
    #[doc = ""]
    #[doc = "  This can only trigger in case of a hardware failure, miscompilation,"]
    #[doc = "  memory corruption, serious bug in the library, or other error would can"]
    #[doc = "  otherwise result in undefined behaviour. It will not trigger due to mere"]
    #[doc = "  incorrect usage of the API (see secp256k1_zkp_context_set_illegal_callback"]
    #[doc = "  for that). After this callback returns, anything may happen, including"]
    #[doc = "  crashing."]
    #[doc = ""]
    #[doc = "  Args: ctx:  an existing context object (cannot be NULL)"]
    #[doc = "  In:   fun:  a pointer to a function to call when an internal error occurs,"]
    #[doc = "              taking a message and an opaque pointer (NULL restores the"]
    #[doc = "              default handler, see secp256k1_zkp_context_set_illegal_callback"]
    #[doc = "              for details)."]
    #[doc = "        data: the opaque pointer to pass to fun above."]
    #[doc = ""]
    #[doc = "  See also secp256k1_zkp_context_set_illegal_callback."]
    pub fn secp256k1_zkp_context_set_error_callback(
        ctx: *mut secp256k1_zkp_context,
        fun: ::std::option::Option<
            unsafe extern "C" fn(
                message: *const ::std::os::raw::c_char,
                data: *mut ::std::os::raw::c_void,
            ),
        >,
        data: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Create a secp256k1 scratch space object."]
    #[doc = ""]
    #[doc = "  Returns: a newly created scratch space."]
    #[doc = "  Args: ctx:  an existing context object (cannot be NULL)"]
    #[doc = "  In:   size: amount of memory to be available as scratch space. Some extra"]
    #[doc = "              (<100 bytes) will be allocated for extra accounting."]
    pub fn secp256k1_zkp_scratch_space_create(
        ctx: *const secp256k1_zkp_context,
        size: size_t,
    ) -> *mut secp256k1_zkp_scratch_space;
}
extern "C" {
    #[doc = " Destroy a secp256k1 scratch space."]
    #[doc = ""]
    #[doc = "  The pointer may not be used afterwards."]
    #[doc = "  Args:       ctx: a secp256k1 context object."]
    #[doc = "          scratch: space to destroy"]
    pub fn secp256k1_zkp_scratch_space_destroy(
        ctx: *const secp256k1_zkp_context,
        scratch: *mut secp256k1_zkp_scratch_space,
    );
}
extern "C" {
    #[doc = " Parse a variable-length public key into the pubkey object."]
    #[doc = ""]
    #[doc = "  Returns: 1 if the public key was fully valid."]
    #[doc = "           0 if the public key could not be parsed or is invalid."]
    #[doc = "  Args: ctx:      a secp256k1 context object."]
    #[doc = "  Out:  pubkey:   pointer to a pubkey object. If 1 is returned, it is set to a"]
    #[doc = "                  parsed version of input. If not, its value is undefined."]
    #[doc = "  In:   input:    pointer to a serialized public key"]
    #[doc = "        inputlen: length of the array pointed to by input"]
    #[doc = ""]
    #[doc = "  This function supports parsing compressed (33 bytes, header byte 0x02 or"]
    #[doc = "  0x03), uncompressed (65 bytes, header byte 0x04), or hybrid (65 bytes, header"]
    #[doc = "  byte 0x06 or 0x07) format public keys."]
    pub fn secp256k1_zkp_ec_pubkey_parse(
        ctx: *const secp256k1_zkp_context,
        pubkey: *mut secp256k1_zkp_pubkey,
        input: *const ::std::os::raw::c_uchar,
        inputlen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Serialize a pubkey object into a serialized byte sequence."]
    #[doc = ""]
    #[doc = "  Returns: 1 always."]
    #[doc = "  Args:   ctx:        a secp256k1 context object."]
    #[doc = "  Out:    output:     a pointer to a 65-byte (if compressed==0) or 33-byte (if"]
    #[doc = "                      compressed==1) byte array to place the serialized key"]
    #[doc = "                      in."]
    #[doc = "  In/Out: outputlen:  a pointer to an integer which is initially set to the"]
    #[doc = "                      size of output, and is overwritten with the written"]
    #[doc = "                      size."]
    #[doc = "  In:     pubkey:     a pointer to a secp256k1_zkp_pubkey containing an"]
    #[doc = "                      initialized public key."]
    #[doc = "          flags:      SECP256K1_EC_COMPRESSED if serialization should be in"]
    #[doc = "                      compressed format, otherwise SECP256K1_EC_UNCOMPRESSED."]
    pub fn secp256k1_zkp_ec_pubkey_serialize(
        ctx: *const secp256k1_zkp_context,
        output: *mut ::std::os::raw::c_uchar,
        outputlen: *mut size_t,
        pubkey: *const secp256k1_zkp_pubkey,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse an ECDSA signature in compact (64 bytes) format."]
    #[doc = ""]
    #[doc = "  Returns: 1 when the signature could be parsed, 0 otherwise."]
    #[doc = "  Args: ctx:      a secp256k1 context object"]
    #[doc = "  Out:  sig:      a pointer to a signature object"]
    #[doc = "  In:   input64:  a pointer to the 64-byte array to parse"]
    #[doc = ""]
    #[doc = "  The signature must consist of a 32-byte big endian R value, followed by a"]
    #[doc = "  32-byte big endian S value. If R or S fall outside of [0..order-1], the"]
    #[doc = "  encoding is invalid. R and S with value 0 are allowed in the encoding."]
    #[doc = ""]
    #[doc = "  After the call, sig will always be initialized. If parsing failed or R or"]
    #[doc = "  S are zero, the resulting sig value is guaranteed to fail validation for any"]
    #[doc = "  message and public key."]
    pub fn secp256k1_zkp_ecdsa_signature_parse_compact(
        ctx: *const secp256k1_zkp_context,
        sig: *mut secp256k1_zkp_ecdsa_signature,
        input64: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse a DER ECDSA signature."]
    #[doc = ""]
    #[doc = "  Returns: 1 when the signature could be parsed, 0 otherwise."]
    #[doc = "  Args: ctx:      a secp256k1 context object"]
    #[doc = "  Out:  sig:      a pointer to a signature object"]
    #[doc = "  In:   input:    a pointer to the signature to be parsed"]
    #[doc = "        inputlen: the length of the array pointed to be input"]
    #[doc = ""]
    #[doc = "  This function will accept any valid DER encoded signature, even if the"]
    #[doc = "  encoded numbers are out of range."]
    #[doc = ""]
    #[doc = "  After the call, sig will always be initialized. If parsing failed or the"]
    #[doc = "  encoded numbers are out of range, signature validation with it is"]
    #[doc = "  guaranteed to fail for every message and public key."]
    pub fn secp256k1_zkp_ecdsa_signature_parse_der(
        ctx: *const secp256k1_zkp_context,
        sig: *mut secp256k1_zkp_ecdsa_signature,
        input: *const ::std::os::raw::c_uchar,
        inputlen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Serialize an ECDSA signature in DER format."]
    #[doc = ""]
    #[doc = "  Returns: 1 if enough space was available to serialize, 0 otherwise"]
    #[doc = "  Args:   ctx:       a secp256k1 context object"]
    #[doc = "  Out:    output:    a pointer to an array to store the DER serialization"]
    #[doc = "  In/Out: outputlen: a pointer to a length integer. Initially, this integer"]
    #[doc = "                     should be set to the length of output. After the call"]
    #[doc = "                     it will be set to the length of the serialization (even"]
    #[doc = "                     if 0 was returned)."]
    #[doc = "  In:     sig:       a pointer to an initialized signature object"]
    pub fn secp256k1_zkp_ecdsa_signature_serialize_der(
        ctx: *const secp256k1_zkp_context,
        output: *mut ::std::os::raw::c_uchar,
        outputlen: *mut size_t,
        sig: *const secp256k1_zkp_ecdsa_signature,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Serialize an ECDSA signature in compact (64 byte) format."]
    #[doc = ""]
    #[doc = "  Returns: 1"]
    #[doc = "  Args:   ctx:       a secp256k1 context object"]
    #[doc = "  Out:    output64:  a pointer to a 64-byte array to store the compact serialization"]
    #[doc = "  In:     sig:       a pointer to an initialized signature object"]
    #[doc = ""]
    #[doc = "  See secp256k1_zkp_ecdsa_signature_parse_compact for details about the encoding."]
    pub fn secp256k1_zkp_ecdsa_signature_serialize_compact(
        ctx: *const secp256k1_zkp_context,
        output64: *mut ::std::os::raw::c_uchar,
        sig: *const secp256k1_zkp_ecdsa_signature,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Verify an ECDSA signature."]
    #[doc = ""]
    #[doc = "  Returns: 1: correct signature"]
    #[doc = "           0: incorrect or unparseable signature"]
    #[doc = "  Args:    ctx:       a secp256k1 context object, initialized for verification."]
    #[doc = "  In:      sig:       the signature being verified (cannot be NULL)"]
    #[doc = "           msg32:     the 32-byte message hash being verified (cannot be NULL)"]
    #[doc = "           pubkey:    pointer to an initialized public key to verify with (cannot be NULL)"]
    #[doc = ""]
    #[doc = " To avoid accepting malleable signatures, only ECDSA signatures in lower-S"]
    #[doc = " form are accepted."]
    #[doc = ""]
    #[doc = " If you need to accept ECDSA signatures from sources that do not obey this"]
    #[doc = " rule, apply secp256k1_zkp_ecdsa_signature_normalize to the signature prior to"]
    #[doc = " validation, but be aware that doing so results in malleable signatures."]
    #[doc = ""]
    #[doc = " For details, see the comments for that function."]
    pub fn secp256k1_zkp_ecdsa_verify(
        ctx: *const secp256k1_zkp_context,
        sig: *const secp256k1_zkp_ecdsa_signature,
        msg32: *const ::std::os::raw::c_uchar,
        pubkey: *const secp256k1_zkp_pubkey,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a signature to a normalized lower-S form."]
    #[doc = ""]
    #[doc = "  Returns: 1 if sigin was not normalized, 0 if it already was."]
    #[doc = "  Args: ctx:    a secp256k1 context object"]
    #[doc = "  Out:  sigout: a pointer to a signature to fill with the normalized form,"]
    #[doc = "                or copy if the input was already normalized. (can be NULL if"]
    #[doc = "                you're only interested in whether the input was already"]
    #[doc = "                normalized)."]
    #[doc = "  In:   sigin:  a pointer to a signature to check/normalize (cannot be NULL,"]
    #[doc = "                can be identical to sigout)"]
    #[doc = ""]
    #[doc = "  With ECDSA a third-party can forge a second distinct signature of the same"]
    #[doc = "  message, given a single initial signature, but without knowing the key. This"]
    #[doc = "  is done by negating the S value modulo the order of the curve, 'flipping'"]
    #[doc = "  the sign of the random point R which is not included in the signature."]
    #[doc = ""]
    #[doc = "  Forgery of the same message isn't universally problematic, but in systems"]
    #[doc = "  where message malleability or uniqueness of signatures is important this can"]
    #[doc = "  cause issues. This forgery can be blocked by all verifiers forcing signers"]
    #[doc = "  to use a normalized form."]
    #[doc = ""]
    #[doc = "  The lower-S form reduces the size of signatures slightly on average when"]
    #[doc = "  variable length encodings (such as DER) are used and is cheap to verify,"]
    #[doc = "  making it a good choice. Security of always using lower-S is assured because"]
    #[doc = "  anyone can trivially modify a signature after the fact to enforce this"]
    #[doc = "  property anyway."]
    #[doc = ""]
    #[doc = "  The lower S value is always between 0x1 and"]
    #[doc = "  0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,"]
    #[doc = "  inclusive."]
    #[doc = ""]
    #[doc = "  No other forms of ECDSA malleability are known and none seem likely, but"]
    #[doc = "  there is no formal proof that ECDSA, even with this additional restriction,"]
    #[doc = "  is free of other malleability. Commonly used serialization schemes will also"]
    #[doc = "  accept various non-unique encodings, so care should be taken when this"]
    #[doc = "  property is required for an application."]
    #[doc = ""]
    #[doc = "  The secp256k1_zkp_ecdsa_sign function will by default create signatures in the"]
    #[doc = "  lower-S form, and secp256k1_zkp_ecdsa_verify will not accept others. In case"]
    #[doc = "  signatures come from a system that cannot enforce this property,"]
    #[doc = "  secp256k1_zkp_ecdsa_signature_normalize must be called before verification."]
    pub fn secp256k1_zkp_ecdsa_signature_normalize(
        ctx: *const secp256k1_zkp_context,
        sigout: *mut secp256k1_zkp_ecdsa_signature,
        sigin: *const secp256k1_zkp_ecdsa_signature,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static secp256k1_zkp_nonce_function_rfc6979: secp256k1_zkp_nonce_function;
}
extern "C" {
    pub static secp256k1_zkp_nonce_function_default: secp256k1_zkp_nonce_function;
}
extern "C" {
    #[doc = " Create an ECDSA signature."]
    #[doc = ""]
    #[doc = "  Returns: 1: signature created"]
    #[doc = "           0: the nonce generation function failed, or the secret key was invalid."]
    #[doc = "  Args:    ctx:    pointer to a context object, initialized for signing (cannot be NULL)"]
    #[doc = "  Out:     sig:    pointer to an array where the signature will be placed (cannot be NULL)"]
    #[doc = "  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)"]
    #[doc = "           seckey: pointer to a 32-byte secret key (cannot be NULL)"]
    #[doc = "           noncefp:pointer to a nonce generation function. If NULL, secp256k1_zkp_nonce_function_default is used"]
    #[doc = "           ndata:  pointer to arbitrary data used by the nonce generation function (can be NULL)"]
    #[doc = ""]
    #[doc = " The created signature is always in lower-S form. See"]
    #[doc = " secp256k1_zkp_ecdsa_signature_normalize for more details."]
    pub fn secp256k1_zkp_ecdsa_sign(
        ctx: *const secp256k1_zkp_context,
        sig: *mut secp256k1_zkp_ecdsa_signature,
        msg32: *const ::std::os::raw::c_uchar,
        seckey: *const ::std::os::raw::c_uchar,
        noncefp: secp256k1_zkp_nonce_function,
        ndata: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Verify an ECDSA secret key."]
    #[doc = ""]
    #[doc = "  A secret key is valid if it is not 0 and less than the secp256k1 curve order"]
    #[doc = "  when interpreted as an integer (most significant byte first). The"]
    #[doc = "  probability of choosing a 32-byte string uniformly at random which is an"]
    #[doc = "  invalid secret key is negligible."]
    #[doc = ""]
    #[doc = "  Returns: 1: secret key is valid"]
    #[doc = "           0: secret key is invalid"]
    #[doc = "  Args:    ctx: pointer to a context object (cannot be NULL)"]
    #[doc = "  In:      seckey: pointer to a 32-byte secret key (cannot be NULL)"]
    pub fn secp256k1_zkp_ec_seckey_verify(
        ctx: *const secp256k1_zkp_context,
        seckey: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compute the public key for a secret key."]
    #[doc = ""]
    #[doc = "  Returns: 1: secret was valid, public key stores"]
    #[doc = "           0: secret was invalid, try again"]
    #[doc = "  Args:   ctx:        pointer to a context object, initialized for signing (cannot be NULL)"]
    #[doc = "  Out:    pubkey:     pointer to the created public key (cannot be NULL)"]
    #[doc = "  In:     seckey:     pointer to a 32-byte secret key (cannot be NULL)"]
    pub fn secp256k1_zkp_ec_pubkey_create(
        ctx: *const secp256k1_zkp_context,
        pubkey: *mut secp256k1_zkp_pubkey,
        seckey: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Negates a secret key in place."]
    #[doc = ""]
    #[doc = "  Returns: 0 if the given secret key is invalid according to"]
    #[doc = "           secp256k1_zkp_ec_seckey_verify. 1 otherwise"]
    #[doc = "  Args:   ctx:    pointer to a context object"]
    #[doc = "  In/Out: seckey: pointer to the 32-byte secret key to be negated. If the"]
    #[doc = "                  secret key is invalid according to"]
    #[doc = "                  secp256k1_zkp_ec_seckey_verify, this function returns 0 and"]
    #[doc = "                  seckey will be set to some unspecified value. (cannot be"]
    #[doc = "                  NULL)"]
    pub fn secp256k1_zkp_ec_seckey_negate(
        ctx: *const secp256k1_zkp_context,
        seckey: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as secp256k1_zkp_ec_seckey_negate, but DEPRECATED. Will be removed in"]
    #[doc = "  future versions."]
    pub fn secp256k1_zkp_ec_privkey_negate(
        ctx: *const secp256k1_zkp_context,
        seckey: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Negates a public key in place."]
    #[doc = ""]
    #[doc = "  Returns: 1 always"]
    #[doc = "  Args:   ctx:        pointer to a context object"]
    #[doc = "  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)"]
    pub fn secp256k1_zkp_ec_pubkey_negate(
        ctx: *const secp256k1_zkp_context,
        pubkey: *mut secp256k1_zkp_pubkey,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tweak a secret key by adding tweak to it."]
    #[doc = ""]
    #[doc = "  Returns: 0 if the arguments are invalid or the resulting secret key would be"]
    #[doc = "           invalid (only when the tweak is the negation of the secret key). 1"]
    #[doc = "           otherwise."]
    #[doc = "  Args:    ctx:   pointer to a context object (cannot be NULL)."]
    #[doc = "  In/Out: seckey: pointer to a 32-byte secret key. If the secret key is"]
    #[doc = "                  invalid according to secp256k1_zkp_ec_seckey_verify, this"]
    #[doc = "                  function returns 0. seckey will be set to some unspecified"]
    #[doc = "                  value if this function returns 0. (cannot be NULL)"]
    #[doc = "  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to"]
    #[doc = "                  secp256k1_zkp_ec_seckey_verify, this function returns 0. For"]
    #[doc = "                  uniformly random 32-byte arrays the chance of being invalid"]
    #[doc = "                  is negligible (around 1 in 2^128) (cannot be NULL)."]
    pub fn secp256k1_zkp_ec_seckey_tweak_add(
        ctx: *const secp256k1_zkp_context,
        seckey: *mut ::std::os::raw::c_uchar,
        tweak: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as secp256k1_zkp_ec_seckey_tweak_add, but DEPRECATED. Will be removed in"]
    #[doc = "  future versions."]
    pub fn secp256k1_zkp_ec_privkey_tweak_add(
        ctx: *const secp256k1_zkp_context,
        seckey: *mut ::std::os::raw::c_uchar,
        tweak: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tweak a public key by adding tweak times the generator to it."]
    #[doc = ""]
    #[doc = "  Returns: 0 if the arguments are invalid or the resulting public key would be"]
    #[doc = "           invalid (only when the tweak is the negation of the corresponding"]
    #[doc = "           secret key). 1 otherwise."]
    #[doc = "  Args:    ctx:   pointer to a context object initialized for validation"]
    #[doc = "                  (cannot be NULL)."]
    #[doc = "  In/Out: pubkey: pointer to a public key object. pubkey will be set to an"]
    #[doc = "                  invalid value if this function returns 0 (cannot be NULL)."]
    #[doc = "  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to"]
    #[doc = "                  secp256k1_zkp_ec_seckey_verify, this function returns 0. For"]
    #[doc = "                  uniformly random 32-byte arrays the chance of being invalid"]
    #[doc = "                  is negligible (around 1 in 2^128) (cannot be NULL)."]
    pub fn secp256k1_zkp_ec_pubkey_tweak_add(
        ctx: *const secp256k1_zkp_context,
        pubkey: *mut secp256k1_zkp_pubkey,
        tweak: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tweak a secret key by multiplying it by a tweak."]
    #[doc = ""]
    #[doc = "  Returns: 0 if the arguments are invalid. 1 otherwise."]
    #[doc = "  Args:   ctx:    pointer to a context object (cannot be NULL)."]
    #[doc = "  In/Out: seckey: pointer to a 32-byte secret key. If the secret key is"]
    #[doc = "                  invalid according to secp256k1_zkp_ec_seckey_verify, this"]
    #[doc = "                  function returns 0. seckey will be set to some unspecified"]
    #[doc = "                  value if this function returns 0. (cannot be NULL)"]
    #[doc = "  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to"]
    #[doc = "                  secp256k1_zkp_ec_seckey_verify, this function returns 0. For"]
    #[doc = "                  uniformly random 32-byte arrays the chance of being invalid"]
    #[doc = "                  is negligible (around 1 in 2^128) (cannot be NULL)."]
    pub fn secp256k1_zkp_ec_seckey_tweak_mul(
        ctx: *const secp256k1_zkp_context,
        seckey: *mut ::std::os::raw::c_uchar,
        tweak: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as secp256k1_zkp_ec_seckey_tweak_mul, but DEPRECATED. Will be removed in"]
    #[doc = "  future versions."]
    pub fn secp256k1_zkp_ec_privkey_tweak_mul(
        ctx: *const secp256k1_zkp_context,
        seckey: *mut ::std::os::raw::c_uchar,
        tweak: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tweak a public key by multiplying it by a tweak value."]
    #[doc = ""]
    #[doc = "  Returns: 0 if the arguments are invalid. 1 otherwise."]
    #[doc = "  Args:    ctx:   pointer to a context object initialized for validation"]
    #[doc = "                  (cannot be NULL)."]
    #[doc = "  In/Out: pubkey: pointer to a public key object. pubkey will be set to an"]
    #[doc = "                  invalid value if this function returns 0 (cannot be NULL)."]
    #[doc = "  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to"]
    #[doc = "                  secp256k1_zkp_ec_seckey_verify, this function returns 0. For"]
    #[doc = "                  uniformly random 32-byte arrays the chance of being invalid"]
    #[doc = "                  is negligible (around 1 in 2^128) (cannot be NULL)."]
    pub fn secp256k1_zkp_ec_pubkey_tweak_mul(
        ctx: *const secp256k1_zkp_context,
        pubkey: *mut secp256k1_zkp_pubkey,
        tweak: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Updates the context randomization to protect against side-channel leakage."]
    #[doc = "  Returns: 1: randomization successfully updated or nothing to randomize"]
    #[doc = "           0: error"]
    #[doc = "  Args:    ctx:       pointer to a context object (cannot be NULL)"]
    #[doc = "  In:      seed32:    pointer to a 32-byte random seed (NULL resets to initial state)"]
    #[doc = ""]
    #[doc = " While secp256k1 code is written to be constant-time no matter what secret"]
    #[doc = " values are, it's possible that a future compiler may output code which isn't,"]
    #[doc = " and also that the CPU may not emit the same radio frequencies or draw the same"]
    #[doc = " amount power for all values."]
    #[doc = ""]
    #[doc = " This function provides a seed which is combined into the blinding value: that"]
    #[doc = " blinding value is added before each multiplication (and removed afterwards) so"]
    #[doc = " that it does not affect function results, but shields against attacks which"]
    #[doc = " rely on any input-dependent behaviour."]
    #[doc = ""]
    #[doc = " This function has currently an effect only on contexts initialized for signing"]
    #[doc = " because randomization is currently used only for signing. However, this is not"]
    #[doc = " guaranteed and may change in the future. It is safe to call this function on"]
    #[doc = " contexts not initialized for signing; then it will have no effect and return 1."]
    #[doc = ""]
    #[doc = " You should call this after secp256k1_zkp_context_create or"]
    #[doc = " secp256k1_zkp_context_clone (and secp256k1_zkp_context_preallocated_create or"]
    #[doc = " secp256k1_zkp_context_clone, resp.), and you may call this repeatedly afterwards."]
    pub fn secp256k1_zkp_context_randomize(
        ctx: *mut secp256k1_zkp_context,
        seed32: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a number of public keys together."]
    #[doc = ""]
    #[doc = "  Returns: 1: the sum of the public keys is valid."]
    #[doc = "           0: the sum of the public keys is not valid."]
    #[doc = "  Args:   ctx:        pointer to a context object"]
    #[doc = "  Out:    out:        pointer to a public key object for placing the resulting public key"]
    #[doc = "                      (cannot be NULL)"]
    #[doc = "  In:     ins:        pointer to array of pointers to public keys (cannot be NULL)"]
    #[doc = "          n:          the number of public keys to add together (must be at least 1)"]
    pub fn secp256k1_zkp_ec_pubkey_combine(
        ctx: *const secp256k1_zkp_context,
        out: *mut secp256k1_zkp_pubkey,
        ins: *const *const secp256k1_zkp_pubkey,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A pointer to a function that hashes an EC point to obtain an ECDH secret"]
#[doc = ""]
#[doc = "  Returns: 1 if the point was successfully hashed."]
#[doc = "           0 will cause secp256k1_zkp_ecdh to fail and return 0."]
#[doc = "           Other return values are not allowed, and the behaviour of"]
#[doc = "           secp256k1_zkp_ecdh is undefined for other return values."]
#[doc = "  Out:     output:     pointer to an array to be filled by the function"]
#[doc = "  In:      x32:        pointer to a 32-byte x coordinate"]
#[doc = "           y32:        pointer to a 32-byte y coordinate"]
#[doc = "           data:       arbitrary data pointer that is passed through"]
pub type secp256k1_zkp_ecdh_hash_function = ::std::option::Option<
    unsafe extern "C" fn(
        output: *mut ::std::os::raw::c_uchar,
        x32: *const ::std::os::raw::c_uchar,
        y32: *const ::std::os::raw::c_uchar,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub static secp256k1_zkp_ecdh_hash_function_sha256: secp256k1_zkp_ecdh_hash_function;
}
extern "C" {
    pub static secp256k1_zkp_ecdh_hash_function_default: secp256k1_zkp_ecdh_hash_function;
}
extern "C" {
    #[doc = " Compute an EC Diffie-Hellman secret in constant time"]
    #[doc = ""]
    #[doc = "  Returns: 1: exponentiation was successful"]
    #[doc = "           0: scalar was invalid (zero or overflow) or hashfp returned 0"]
    #[doc = "  Args:    ctx:        pointer to a context object (cannot be NULL)"]
    #[doc = "  Out:     output:     pointer to an array to be filled by hashfp"]
    #[doc = "  In:      pubkey:     a pointer to a secp256k1_zkp_pubkey containing an"]
    #[doc = "                       initialized public key"]
    #[doc = "           seckey:     a 32-byte scalar with which to multiply the point"]
    #[doc = "           hashfp:     pointer to a hash function. If NULL, secp256k1_zkp_ecdh_hash_function_sha256 is used"]
    #[doc = "                       (in which case, 32 bytes will be written to output)"]
    #[doc = "           data:       arbitrary data pointer that is passed through to hashfp"]
    pub fn secp256k1_zkp_ecdh(
        ctx: *const secp256k1_zkp_context,
        output: *mut ::std::os::raw::c_uchar,
        pubkey: *const secp256k1_zkp_pubkey,
        seckey: *const ::std::os::raw::c_uchar,
        hashfp: secp256k1_zkp_ecdh_hash_function,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Opaque data structure that holds a parsed and valid \"x-only\" public key."]
#[doc = "  An x-only pubkey encodes a point whose Y coordinate is even. It is"]
#[doc = "  serialized using only its X coordinate (32 bytes). See BIP-340 for more"]
#[doc = "  information about x-only pubkeys."]
#[doc = ""]
#[doc = "  The exact representation of data inside is implementation defined and not"]
#[doc = "  guaranteed to be portable between different platforms or versions. It is"]
#[doc = "  however guaranteed to be 64 bytes in size, and can be safely copied/moved."]
#[doc = "  If you need to convert to a format suitable for storage, transmission, or"]
#[doc = "  comparison, use secp256k1_zkp_xonly_pubkey_serialize and"]
#[doc = "  secp256k1_zkp_xonly_pubkey_parse."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct secp256k1_zkp_xonly_pubkey {
    pub data: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_secp256k1_zkp_xonly_pubkey() {
    assert_eq!(
        ::std::mem::size_of::<secp256k1_zkp_xonly_pubkey>(),
        64usize,
        concat!("Size of: ", stringify!(secp256k1_zkp_xonly_pubkey))
    );
    assert_eq!(
        ::std::mem::align_of::<secp256k1_zkp_xonly_pubkey>(),
        1usize,
        concat!("Alignment of ", stringify!(secp256k1_zkp_xonly_pubkey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<secp256k1_zkp_xonly_pubkey>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_xonly_pubkey),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Opaque data structure that holds a keypair consisting of a secret and a"]
#[doc = "  public key."]
#[doc = ""]
#[doc = "  The exact representation of data inside is implementation defined and not"]
#[doc = "  guaranteed to be portable between different platforms or versions. It is"]
#[doc = "  however guaranteed to be 96 bytes in size, and can be safely copied/moved."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct secp256k1_zkp_keypair {
    pub data: [::std::os::raw::c_uchar; 96usize],
}
#[test]
fn bindgen_test_layout_secp256k1_zkp_keypair() {
    assert_eq!(
        ::std::mem::size_of::<secp256k1_zkp_keypair>(),
        96usize,
        concat!("Size of: ", stringify!(secp256k1_zkp_keypair))
    );
    assert_eq!(
        ::std::mem::align_of::<secp256k1_zkp_keypair>(),
        1usize,
        concat!("Alignment of ", stringify!(secp256k1_zkp_keypair))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<secp256k1_zkp_keypair>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_keypair),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Parse a 32-byte sequence into a xonly_pubkey object."]
    #[doc = ""]
    #[doc = "  Returns: 1 if the public key was fully valid."]
    #[doc = "           0 if the public key could not be parsed or is invalid."]
    #[doc = ""]
    #[doc = "  Args:   ctx: a secp256k1 context object (cannot be NULL)."]
    #[doc = "  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a"]
    #[doc = "               parsed version of input. If not, it's set to an invalid value."]
    #[doc = "               (cannot be NULL)."]
    #[doc = "  In: input32: pointer to a serialized xonly_pubkey (cannot be NULL)"]
    pub fn secp256k1_zkp_xonly_pubkey_parse(
        ctx: *const secp256k1_zkp_context,
        pubkey: *mut secp256k1_zkp_xonly_pubkey,
        input32: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Serialize an xonly_pubkey object into a 32-byte sequence."]
    #[doc = ""]
    #[doc = "  Returns: 1 always."]
    #[doc = ""]
    #[doc = "  Args:     ctx: a secp256k1 context object (cannot be NULL)."]
    #[doc = "  Out: output32: a pointer to a 32-byte array to place the serialized key in"]
    #[doc = "                 (cannot be NULL)."]
    #[doc = "  In:    pubkey: a pointer to a secp256k1_zkp_xonly_pubkey containing an"]
    #[doc = "                 initialized public key (cannot be NULL)."]
    pub fn secp256k1_zkp_xonly_pubkey_serialize(
        ctx: *const secp256k1_zkp_context,
        output32: *mut ::std::os::raw::c_uchar,
        pubkey: *const secp256k1_zkp_xonly_pubkey,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts a secp256k1_zkp_pubkey into a secp256k1_zkp_xonly_pubkey."]
    #[doc = ""]
    #[doc = "  Returns: 1 if the public key was successfully converted"]
    #[doc = "           0 otherwise"]
    #[doc = ""]
    #[doc = "  Args:         ctx: pointer to a context object (cannot be NULL)"]
    #[doc = "  Out: xonly_pubkey: pointer to an x-only public key object for placing the"]
    #[doc = "                     converted public key (cannot be NULL)"]
    #[doc = "          pk_parity: pointer to an integer that will be set to 1 if the point"]
    #[doc = "                     encoded by xonly_pubkey is the negation of the pubkey and"]
    #[doc = "                     set to 0 otherwise. (can be NULL)"]
    #[doc = "  In:        pubkey: pointer to a public key that is converted (cannot be NULL)"]
    pub fn secp256k1_zkp_xonly_pubkey_from_pubkey(
        ctx: *const secp256k1_zkp_context,
        xonly_pubkey: *mut secp256k1_zkp_xonly_pubkey,
        pk_parity: *mut ::std::os::raw::c_int,
        pubkey: *const secp256k1_zkp_pubkey,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tweak an x-only public key by adding the generator multiplied with tweak32"]
    #[doc = "  to it."]
    #[doc = ""]
    #[doc = "  Note that the resulting point can not in general be represented by an x-only"]
    #[doc = "  pubkey because it may have an odd Y coordinate. Instead, the output_pubkey"]
    #[doc = "  is a normal secp256k1_zkp_pubkey."]
    #[doc = ""]
    #[doc = "  Returns: 0 if the arguments are invalid or the resulting public key would be"]
    #[doc = "           invalid (only when the tweak is the negation of the corresponding"]
    #[doc = "           secret key). 1 otherwise."]
    #[doc = ""]
    #[doc = "  Args:           ctx: pointer to a context object initialized for verification"]
    #[doc = "                       (cannot be NULL)"]
    #[doc = "  Out:  output_pubkey: pointer to a public key to store the result. Will be set"]
    #[doc = "                       to an invalid value if this function returns 0 (cannot"]
    #[doc = "                       be NULL)"]
    #[doc = "  In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to."]
    #[doc = "                       (cannot be NULL)."]
    #[doc = "              tweak32: pointer to a 32-byte tweak. If the tweak is invalid"]
    #[doc = "                       according to secp256k1_zkp_ec_seckey_verify, this function"]
    #[doc = "                       returns 0. For uniformly random 32-byte arrays the"]
    #[doc = "                       chance of being invalid is negligible (around 1 in"]
    #[doc = "                       2^128) (cannot be NULL)."]
    pub fn secp256k1_zkp_xonly_pubkey_tweak_add(
        ctx: *const secp256k1_zkp_context,
        output_pubkey: *mut secp256k1_zkp_pubkey,
        internal_pubkey: *const secp256k1_zkp_xonly_pubkey,
        tweak32: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks that a tweaked pubkey is the result of calling"]
    #[doc = "  secp256k1_zkp_xonly_pubkey_tweak_add with internal_pubkey and tweak32."]
    #[doc = ""]
    #[doc = "  The tweaked pubkey is represented by its 32-byte x-only serialization and"]
    #[doc = "  its pk_parity, which can both be obtained by converting the result of"]
    #[doc = "  tweak_add to a secp256k1_zkp_xonly_pubkey."]
    #[doc = ""]
    #[doc = "  Note that this alone does _not_ verify that the tweaked pubkey is a"]
    #[doc = "  commitment. If the tweak is not chosen in a specific way, the tweaked pubkey"]
    #[doc = "  can easily be the result of a different internal_pubkey and tweak."]
    #[doc = ""]
    #[doc = "  Returns: 0 if the arguments are invalid or the tweaked pubkey is not the"]
    #[doc = "           result of tweaking the internal_pubkey with tweak32. 1 otherwise."]
    #[doc = "  Args:            ctx: pointer to a context object initialized for verification"]
    #[doc = "                       (cannot be NULL)"]
    #[doc = "  In: tweaked_pubkey32: pointer to a serialized xonly_pubkey (cannot be NULL)"]
    #[doc = "     tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization"]
    #[doc = "                        is passed in as tweaked_pubkey32). This must match the"]
    #[doc = "                        pk_parity value that is returned when calling"]
    #[doc = "                        secp256k1_zkp_xonly_pubkey with the tweaked pubkey, or"]
    #[doc = "                        this function will fail."]
    #[doc = "       internal_pubkey: pointer to an x-only public key object to apply the"]
    #[doc = "                        tweak to (cannot be NULL)"]
    #[doc = "               tweak32: pointer to a 32-byte tweak (cannot be NULL)"]
    pub fn secp256k1_zkp_xonly_pubkey_tweak_add_check(
        ctx: *const secp256k1_zkp_context,
        tweaked_pubkey32: *const ::std::os::raw::c_uchar,
        tweaked_pk_parity: ::std::os::raw::c_int,
        internal_pubkey: *const secp256k1_zkp_xonly_pubkey,
        tweak32: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compute the keypair for a secret key."]
    #[doc = ""]
    #[doc = "  Returns: 1: secret was valid, keypair is ready to use"]
    #[doc = "           0: secret was invalid, try again with a different secret"]
    #[doc = "  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)"]
    #[doc = "  Out: keypair: pointer to the created keypair (cannot be NULL)"]
    #[doc = "  In:   seckey: pointer to a 32-byte secret key (cannot be NULL)"]
    pub fn secp256k1_zkp_keypair_create(
        ctx: *const secp256k1_zkp_context,
        keypair: *mut secp256k1_zkp_keypair,
        seckey: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the public key from a keypair."]
    #[doc = ""]
    #[doc = "  Returns: 0 if the arguments are invalid. 1 otherwise."]
    #[doc = "  Args:    ctx: pointer to a context object (cannot be NULL)"]
    #[doc = "  Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to"]
    #[doc = "               the keypair public key. If not, it's set to an invalid value."]
    #[doc = "               (cannot be NULL)"]
    #[doc = "  In: keypair: pointer to a keypair (cannot be NULL)"]
    pub fn secp256k1_zkp_keypair_pub(
        ctx: *const secp256k1_zkp_context,
        pubkey: *mut secp256k1_zkp_pubkey,
        keypair: *const secp256k1_zkp_keypair,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the x-only public key from a keypair."]
    #[doc = ""]
    #[doc = "  This is the same as calling secp256k1_zkp_keypair_pub and then"]
    #[doc = "  secp256k1_zkp_xonly_pubkey_from_pubkey."]
    #[doc = ""]
    #[doc = "  Returns: 0 if the arguments are invalid. 1 otherwise."]
    #[doc = "  Args:   ctx: pointer to a context object (cannot be NULL)"]
    #[doc = "  Out: pubkey: pointer to an xonly_pubkey object. If 1 is returned, it is set"]
    #[doc = "               to the keypair public key after converting it to an"]
    #[doc = "               xonly_pubkey. If not, it's set to an invalid value (cannot be"]
    #[doc = "               NULL)."]
    #[doc = "    pk_parity: pointer to an integer that will be set to the pk_parity"]
    #[doc = "               argument of secp256k1_zkp_xonly_pubkey_from_pubkey (can be NULL)."]
    #[doc = "  In: keypair: pointer to a keypair (cannot be NULL)"]
    pub fn secp256k1_zkp_keypair_xonly_pub(
        ctx: *const secp256k1_zkp_context,
        pubkey: *mut secp256k1_zkp_xonly_pubkey,
        pk_parity: *mut ::std::os::raw::c_int,
        keypair: *const secp256k1_zkp_keypair,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tweak a keypair by adding tweak32 to the secret key and updating the public"]
    #[doc = "  key accordingly."]
    #[doc = ""]
    #[doc = "  Calling this function and then secp256k1_zkp_keypair_pub results in the same"]
    #[doc = "  public key as calling secp256k1_zkp_keypair_xonly_pub and then"]
    #[doc = "  secp256k1_zkp_xonly_pubkey_tweak_add."]
    #[doc = ""]
    #[doc = "  Returns: 0 if the arguments are invalid or the resulting keypair would be"]
    #[doc = "           invalid (only when the tweak is the negation of the keypair's"]
    #[doc = "           secret key). 1 otherwise."]
    #[doc = ""]
    #[doc = "  Args:       ctx: pointer to a context object initialized for verification"]
    #[doc = "                   (cannot be NULL)"]
    #[doc = "  In/Out: keypair: pointer to a keypair to apply the tweak to. Will be set to"]
    #[doc = "                   an invalid value if this function returns 0 (cannot be"]
    #[doc = "                   NULL)."]
    #[doc = "  In:     tweak32: pointer to a 32-byte tweak. If the tweak is invalid according"]
    #[doc = "                   to secp256k1_zkp_ec_seckey_verify, this function returns 0. For"]
    #[doc = "                   uniformly random 32-byte arrays the chance of being invalid"]
    #[doc = "                   is negligible (around 1 in 2^128) (cannot be NULL)."]
    pub fn secp256k1_zkp_keypair_xonly_tweak_add(
        ctx: *const secp256k1_zkp_context,
        keypair: *mut secp256k1_zkp_keypair,
        tweak32: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " Opaque data structure that stores a base point"]
#[doc = ""]
#[doc = "  The exact representation of data inside is implementation defined and not"]
#[doc = "  guaranteed to be portable between different platforms or versions. It is"]
#[doc = "  however guaranteed to be 64 bytes in size, and can be safely copied/moved."]
#[doc = "  If you need to convert to a format suitable for storage, transmission, or"]
#[doc = "  comparison, use secp256k1_zkp_generator_serialize and secp256k1_zkp_generator_parse."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct secp256k1_zkp_generator {
    pub data: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_secp256k1_zkp_generator() {
    assert_eq!(
        ::std::mem::size_of::<secp256k1_zkp_generator>(),
        64usize,
        concat!("Size of: ", stringify!(secp256k1_zkp_generator))
    );
    assert_eq!(
        ::std::mem::align_of::<secp256k1_zkp_generator>(),
        1usize,
        concat!("Alignment of ", stringify!(secp256k1_zkp_generator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<secp256k1_zkp_generator>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_generator),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Parse a 33-byte generator byte sequence into a generator object."]
    #[doc = ""]
    #[doc = "  Returns: 1 if input contains a valid generator."]
    #[doc = "  Args: ctx:      a secp256k1 context object."]
    #[doc = "  Out:  gen:      pointer to the output generator object"]
    #[doc = "  In:   input:    pointer to a 33-byte serialized generator"]
    pub fn secp256k1_zkp_generator_parse(
        ctx: *const secp256k1_zkp_context,
        gen: *mut secp256k1_zkp_generator,
        input: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Serialize a 33-byte generator into a serialized byte sequence."]
    #[doc = ""]
    #[doc = "  Returns: 1 always."]
    #[doc = "  Args:   ctx:        a secp256k1 context object."]
    #[doc = "  Out:    output:     a pointer to a 33-byte byte array"]
    #[doc = "  In:     gen:        a pointer to a generator"]
    pub fn secp256k1_zkp_generator_serialize(
        ctx: *const secp256k1_zkp_context,
        output: *mut ::std::os::raw::c_uchar,
        gen: *const secp256k1_zkp_generator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate a generator for the curve."]
    #[doc = ""]
    #[doc = "  Returns: 0 in the highly unlikely case the seed is not acceptable,"]
    #[doc = "           1 otherwise."]
    #[doc = "  Args: ctx:     a secp256k1 context object"]
    #[doc = "  Out:  gen:     a generator object"]
    #[doc = "  In:   seed32:  a 32-byte seed"]
    #[doc = ""]
    #[doc = "  If successful a valid generator will be placed in gen. The produced"]
    #[doc = "  generators are distributed uniformly over the curve, and will not have a"]
    #[doc = "  known discrete logarithm with respect to any other generator produced,"]
    #[doc = "  or to the base generator G."]
    pub fn secp256k1_zkp_generator_generate(
        ctx: *const secp256k1_zkp_context,
        gen: *mut secp256k1_zkp_generator,
        seed32: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate a blinded generator for the curve."]
    #[doc = ""]
    #[doc = "  Returns: 0 in the highly unlikely case the seed is not acceptable or when"]
    #[doc = "           blind is out of range. 1 otherwise."]
    #[doc = "  Args: ctx:     a secp256k1 context object, initialized for signing"]
    #[doc = "  Out:  gen:     a generator object"]
    #[doc = "  In:   seed32:  a 32-byte seed"]
    #[doc = "        blind32: a 32-byte secret value to blind the generator with."]
    #[doc = ""]
    #[doc = "  The result is equivalent to first calling secp256k1_zkp_generator_generate,"]
    #[doc = "  converting the result to a public key, calling secp256k1_zkp_ec_pubkey_tweak_add,"]
    #[doc = "  and then converting back to generator form."]
    pub fn secp256k1_zkp_generator_generate_blinded(
        ctx: *const secp256k1_zkp_context,
        gen: *mut secp256k1_zkp_generator,
        key32: *const ::std::os::raw::c_uchar,
        blind32: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Data structure containing auxiliary data generated in `pubkey_combine` and"]
#[doc = "  required for `session_*_initialize`."]
#[doc = "  Fields:"]
#[doc = "          magic: Set during initialization in `pubkey_combine` in order to allow"]
#[doc = "                 detecting an uninitialized object."]
#[doc = "        pk_hash: The 32-byte hash of the original public keys"]
#[doc = "     is_negated: Whether the MuSig-aggregated point was negated when"]
#[doc = "                 converting it to the combined xonly pubkey."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct secp256k1_zkp_musig_pre_session {
    pub magic: u64,
    pub pk_hash: [::std::os::raw::c_uchar; 32usize],
    pub is_negated: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_secp256k1_zkp_musig_pre_session() {
    assert_eq!(
        ::std::mem::size_of::<secp256k1_zkp_musig_pre_session>(),
        48usize,
        concat!("Size of: ", stringify!(secp256k1_zkp_musig_pre_session))
    );
    assert_eq!(
        ::std::mem::align_of::<secp256k1_zkp_musig_pre_session>(),
        8usize,
        concat!("Alignment of ", stringify!(secp256k1_zkp_musig_pre_session))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_pre_session>())).magic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_pre_session),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_pre_session>())).pk_hash as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_pre_session),
            "::",
            stringify!(pk_hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_pre_session>())).is_negated as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_pre_session),
            "::",
            stringify!(is_negated)
        )
    );
}
#[doc = " Data structure containing data related to a signing session resulting in a single"]
#[doc = " signature."]
#[doc = ""]
#[doc = " This structure is not opaque, but it MUST NOT be copied or read or written to it"]
#[doc = " directly. A signer who is online throughout the whole process and can keep this"]
#[doc = " structure in memory can use the provided API functions for a safe standard"]
#[doc = " workflow. See https://blockstream.com/2019/02/18/musig-a-new-multisignature-standard/"]
#[doc = " for more details about the risks associated with serializing or deserializing this"]
#[doc = " structure."]
#[doc = ""]
#[doc = " Fields:"]
#[doc = "      combined_pk: MuSig-computed combined xonly public key"]
#[doc = "      pre_session: Auxiliary data created in `pubkey_combine`"]
#[doc = "        n_signers: Number of signers"]
#[doc = "   combined_nonce: Summed combined public nonce (undefined if `nonce_is_set` is false)"]
#[doc = "     nonce_is_set: Whether the above nonce has been set"]
#[doc = " nonce_is_negated: If `nonce_is_set`, whether the above nonce was negated after"]
#[doc = "                   summing the participants' nonces. Needed to ensure the nonce's y"]
#[doc = "                   coordinate is even."]
#[doc = "              msg: The 32-byte message (hash) to be signed"]
#[doc = "       msg_is_set: Whether the above message has been set"]
#[doc = "  has_secret_data: Whether this session object has a signers' secret data; if this"]
#[doc = "                   is `false`, it may still be used for verification purposes."]
#[doc = "           seckey: If `has_secret_data`, the signer's secret key"]
#[doc = "         secnonce: If `has_secret_data`, the signer's secret nonce"]
#[doc = "            nonce: If `has_secret_data`, the signer's public nonce"]
#[doc = " nonce_commitments_hash: If `has_secret_data` and `nonce_commitments_hash_is_set`,"]
#[doc = "                   the hash of all signers' commitments"]
#[doc = " nonce_commitments_hash_is_set: If `has_secret_data`, whether the"]
#[doc = "                   nonce_commitments_hash has been set"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct secp256k1_zkp_musig_session {
    pub combined_pk: secp256k1_zkp_xonly_pubkey,
    pub pre_session: secp256k1_zkp_musig_pre_session,
    pub n_signers: u32,
    pub combined_nonce: secp256k1_zkp_pubkey,
    pub nonce_is_set: ::std::os::raw::c_int,
    pub nonce_is_negated: ::std::os::raw::c_int,
    pub msg: [::std::os::raw::c_uchar; 32usize],
    pub msg_is_set: ::std::os::raw::c_int,
    pub has_secret_data: ::std::os::raw::c_int,
    pub seckey: [::std::os::raw::c_uchar; 32usize],
    pub secnonce: [::std::os::raw::c_uchar; 32usize],
    pub nonce: secp256k1_zkp_pubkey,
    pub nonce_commitments_hash: [::std::os::raw::c_uchar; 32usize],
    pub nonce_commitments_hash_is_set: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_secp256k1_zkp_musig_session() {
    assert_eq!(
        ::std::mem::size_of::<secp256k1_zkp_musig_session>(),
        392usize,
        concat!("Size of: ", stringify!(secp256k1_zkp_musig_session))
    );
    assert_eq!(
        ::std::mem::align_of::<secp256k1_zkp_musig_session>(),
        8usize,
        concat!("Alignment of ", stringify!(secp256k1_zkp_musig_session))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_session>())).combined_pk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session),
            "::",
            stringify!(combined_pk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_session>())).pre_session as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session),
            "::",
            stringify!(pre_session)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_session>())).n_signers as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session),
            "::",
            stringify!(n_signers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_session>())).combined_nonce as *const _
                as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session),
            "::",
            stringify!(combined_nonce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_session>())).nonce_is_set as *const _
                as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session),
            "::",
            stringify!(nonce_is_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_session>())).nonce_is_negated as *const _
                as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session),
            "::",
            stringify!(nonce_is_negated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<secp256k1_zkp_musig_session>())).msg as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_session>())).msg_is_set as *const _ as usize
        },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session),
            "::",
            stringify!(msg_is_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_session>())).has_secret_data as *const _
                as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session),
            "::",
            stringify!(has_secret_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_session>())).seckey as *const _ as usize
        },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session),
            "::",
            stringify!(seckey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_session>())).secnonce as *const _ as usize
        },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session),
            "::",
            stringify!(secnonce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_session>())).nonce as *const _ as usize
        },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session),
            "::",
            stringify!(nonce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_session>())).nonce_commitments_hash
                as *const _ as usize
        },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session),
            "::",
            stringify!(nonce_commitments_hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_session>())).nonce_commitments_hash_is_set
                as *const _ as usize
        },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session),
            "::",
            stringify!(nonce_commitments_hash_is_set)
        )
    );
}
#[doc = " Data structure containing data on all signers in a single session."]
#[doc = ""]
#[doc = " The workflow for this structure is as follows:"]
#[doc = ""]
#[doc = " 1. This structure is initialized with `musig_session_initialize` or"]
#[doc = "    `musig_session_initialize_verifier`, which set the `index` field, and zero out"]
#[doc = "    all other fields. The public session is initialized with the signers'"]
#[doc = "    nonce_commitments."]
#[doc = ""]
#[doc = " 2. In a non-public session the nonce_commitments are set with the function"]
#[doc = "    `musig_get_public_nonce`, which also returns the signer's public nonce. This"]
#[doc = "    ensures that the public nonce is not exposed until all commitments have been"]
#[doc = "    received."]
#[doc = ""]
#[doc = " 3. Each individual data struct should be updated with `musig_set_nonce` once a"]
#[doc = "    nonce is available. This function takes a single signer data struct rather than"]
#[doc = "    an array because it may fail in the case that the provided nonce does not match"]
#[doc = "    the commitment. In this case, it is desirable to identify the exact party whose"]
#[doc = "    nonce was inconsistent."]
#[doc = ""]
#[doc = " Fields:"]
#[doc = "   present: indicates whether the signer's nonce is set"]
#[doc = "     index: index of the signer in the MuSig key aggregation"]
#[doc = "     nonce: public nonce, must be a valid curvepoint if the signer is `present`"]
#[doc = " nonce_commitment: commitment to the nonce, or all-bits zero if a commitment"]
#[doc = "                   has not yet been set"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct secp256k1_zkp_musig_session_signer_data {
    pub present: ::std::os::raw::c_int,
    pub index: u32,
    pub nonce: secp256k1_zkp_pubkey,
    pub nonce_commitment: [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_secp256k1_zkp_musig_session_signer_data() {
    assert_eq!(
        ::std::mem::size_of::<secp256k1_zkp_musig_session_signer_data>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(secp256k1_zkp_musig_session_signer_data)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<secp256k1_zkp_musig_session_signer_data>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(secp256k1_zkp_musig_session_signer_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_session_signer_data>())).present as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session_signer_data),
            "::",
            stringify!(present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_session_signer_data>())).index as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session_signer_data),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_session_signer_data>())).nonce as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session_signer_data),
            "::",
            stringify!(nonce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_session_signer_data>())).nonce_commitment
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_session_signer_data),
            "::",
            stringify!(nonce_commitment)
        )
    );
}
#[doc = " Opaque data structure that holds a MuSig partial signature."]
#[doc = ""]
#[doc = "  The exact representation of data inside is implementation defined and not"]
#[doc = "  guaranteed to be portable between different platforms or versions. It is however"]
#[doc = "  guaranteed to be 32 bytes in size, and can be safely copied/moved. If you need"]
#[doc = "  to convert to a format suitable for storage, transmission, or comparison, use the"]
#[doc = "  `musig_partial_signature_serialize` and `musig_partial_signature_parse`"]
#[doc = "  functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct secp256k1_zkp_musig_partial_signature {
    pub data: [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_secp256k1_zkp_musig_partial_signature() {
    assert_eq!(
        ::std::mem::size_of::<secp256k1_zkp_musig_partial_signature>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(secp256k1_zkp_musig_partial_signature)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<secp256k1_zkp_musig_partial_signature>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(secp256k1_zkp_musig_partial_signature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_musig_partial_signature>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_musig_partial_signature),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Computes a combined public key and the hash of the given public keys"]
    #[doc = ""]
    #[doc = "  Returns: 1 if the public keys were successfully combined, 0 otherwise"]
    #[doc = "  Args:        ctx: pointer to a context object initialized for verification"]
    #[doc = "                    (cannot be NULL)"]
    #[doc = "           scratch: scratch space used to compute the combined pubkey by"]
    #[doc = "                    multiexponentiation. If NULL, an inefficient algorithm is used."]
    #[doc = "  Out: combined_pk: the MuSig-combined xonly public key (cannot be NULL)"]
    #[doc = "       pre_session: if non-NULL, pointer to a musig_pre_session struct to be used in"]
    #[doc = "                    `musig_session_initialize`."]
    #[doc = "   In:     pubkeys: input array of public keys to combine. The order is important;"]
    #[doc = "                    a different order will result in a different combined public"]
    #[doc = "                    key (cannot be NULL)"]
    #[doc = "         n_pubkeys: length of pubkeys array"]
    pub fn secp256k1_zkp_musig_pubkey_combine(
        ctx: *const secp256k1_zkp_context,
        scratch: *mut secp256k1_zkp_scratch_space,
        combined_pk: *mut secp256k1_zkp_xonly_pubkey,
        pre_session: *mut secp256k1_zkp_musig_pre_session,
        pubkeys: *const secp256k1_zkp_xonly_pubkey,
        n_pubkeys: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes a signing session for a signer"]
    #[doc = ""]
    #[doc = "  Returns: 1: session is successfully initialized"]
    #[doc = "           0: session could not be initialized: secret key or secret nonce overflow"]
    #[doc = "  Args:         ctx: pointer to a context object, initialized for signing (cannot"]
    #[doc = "                     be NULL)"]
    #[doc = "  Out:      session: the session structure to initialize (cannot be NULL)"]
    #[doc = "            signers: an array of signers' data to be initialized. Array length must"]
    #[doc = "                     equal to `n_signers` (cannot be NULL)"]
    #[doc = " nonce_commitment32: filled with a 32-byte commitment to the generated nonce"]
    #[doc = "                     (cannot be NULL)"]
    #[doc = "  In:  session_id32: a *unique* 32-byte ID to assign to this session (cannot be"]
    #[doc = "                     NULL). If a non-unique session_id32 was given then a partial"]
    #[doc = "                     signature will LEAK THE SECRET KEY."]
    #[doc = "              msg32: the 32-byte message to be signed. Shouldn't be NULL unless you"]
    #[doc = "                     require sharing nonce commitments before the message is known"]
    #[doc = "                     because it reduces nonce misuse resistance. If NULL, must be"]
    #[doc = "                     set with `musig_session_get_public_nonce`."]
    #[doc = "        combined_pk: the combined xonly public key of all signers (cannot be NULL)"]
    #[doc = "        pre_session: pointer to a musig_pre_session struct from"]
    #[doc = "                     `musig_pubkey_combine` (cannot be NULL)"]
    #[doc = "          n_signers: length of signers array. Number of signers participating in"]
    #[doc = "                     the MuSig. Must be greater than 0 and at most 2^32 - 1."]
    #[doc = "           my_index: index of this signer in the signers array"]
    #[doc = "             seckey: the signer's 32-byte secret key (cannot be NULL)"]
    pub fn secp256k1_zkp_musig_session_initialize(
        ctx: *const secp256k1_zkp_context,
        session: *mut secp256k1_zkp_musig_session,
        signers: *mut secp256k1_zkp_musig_session_signer_data,
        nonce_commitment32: *mut ::std::os::raw::c_uchar,
        session_id32: *const ::std::os::raw::c_uchar,
        msg32: *const ::std::os::raw::c_uchar,
        combined_pk: *const secp256k1_zkp_xonly_pubkey,
        pre_session: *const secp256k1_zkp_musig_pre_session,
        n_signers: size_t,
        my_index: size_t,
        seckey: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the signer's public nonce given a list of all signers' data with commitments"]
    #[doc = ""]
    #[doc = "  Returns: 1: public nonce is written in nonce"]
    #[doc = "           0: signer data is missing commitments or session isn't initialized"]
    #[doc = "              for signing"]
    #[doc = "  Args:        ctx: pointer to a context object (cannot be NULL)"]
    #[doc = "           session: the signing session to get the nonce from (cannot be NULL)"]
    #[doc = "           signers: an array of signers' data initialized with"]
    #[doc = "                    `musig_session_initialize`. Array length must equal to"]
    #[doc = "                    `n_commitments` (cannot be NULL)"]
    #[doc = "  Out:       nonce: the nonce (cannot be NULL)"]
    #[doc = "  In:  commitments: array of 32-byte nonce commitments (cannot be NULL)"]
    #[doc = "     n_commitments: the length of commitments and signers array. Must be the total"]
    #[doc = "                    number of signers participating in the MuSig."]
    #[doc = "             msg32: the 32-byte message to be signed. Must be NULL if already"]
    #[doc = "                    set with `musig_session_initialize` otherwise can not be NULL."]
    pub fn secp256k1_zkp_musig_session_get_public_nonce(
        ctx: *const secp256k1_zkp_context,
        session: *mut secp256k1_zkp_musig_session,
        signers: *mut secp256k1_zkp_musig_session_signer_data,
        nonce: *mut secp256k1_zkp_pubkey,
        commitments: *const *const ::std::os::raw::c_uchar,
        n_commitments: size_t,
        msg32: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes a verifier session that can be used for verifying nonce commitments"]
    #[doc = "  and partial signatures. It does not have secret key material and therefore can not"]
    #[doc = "  be used to create signatures."]
    #[doc = ""]
    #[doc = "  Returns: 1 when session is successfully initialized, 0 otherwise"]
    #[doc = "  Args:        ctx: pointer to a context object (cannot be NULL)"]
    #[doc = "  Out:     session: the session structure to initialize (cannot be NULL)"]
    #[doc = "           signers: an array of signers' data to be initialized. Array length must"]
    #[doc = "                    equal to `n_signers`(cannot be NULL)"]
    #[doc = "  In:        msg32: the 32-byte message to be signed (cannot be NULL)"]
    #[doc = "       combined_pk: the combined xonly public key of all signers (cannot be NULL)"]
    #[doc = "       pre_session: pointer to a musig_pre_session struct from"]
    #[doc = "                    `musig_pubkey_combine` (cannot be NULL)"]
    #[doc = "         pk_hash32: the 32-byte hash of the signers' individual keys (cannot be NULL)"]
    #[doc = "       commitments: array of 32-byte nonce commitments. Array length must equal to"]
    #[doc = "                    `n_signers` (cannot be NULL)"]
    #[doc = "         n_signers: length of signers and commitments array. Number of signers"]
    #[doc = "                    participating in the MuSig. Must be greater than 0 and at most"]
    #[doc = "                    2^32 - 1."]
    pub fn secp256k1_zkp_musig_session_initialize_verifier(
        ctx: *const secp256k1_zkp_context,
        session: *mut secp256k1_zkp_musig_session,
        signers: *mut secp256k1_zkp_musig_session_signer_data,
        msg32: *const ::std::os::raw::c_uchar,
        combined_pk: *const secp256k1_zkp_xonly_pubkey,
        pre_session: *const secp256k1_zkp_musig_pre_session,
        commitments: *const *const ::std::os::raw::c_uchar,
        n_signers: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks a signer's public nonce against a commitment to said nonce, and update"]
    #[doc = "  data structure if they match"]
    #[doc = ""]
    #[doc = "  Returns: 1: commitment was valid, data structure updated"]
    #[doc = "           0: commitment was invalid, nothing happened"]
    #[doc = "  Args:      ctx: pointer to a context object (cannot be NULL)"]
    #[doc = "          signer: pointer to the signer data to update (cannot be NULL). Must have"]
    #[doc = "                  been used with `musig_session_get_public_nonce` or initialized"]
    #[doc = "                  with `musig_session_initialize_verifier`."]
    #[doc = "  In:     nonce: signer's alleged public nonce (cannot be NULL)"]
    pub fn secp256k1_zkp_musig_set_nonce(
        ctx: *const secp256k1_zkp_context,
        signer: *mut secp256k1_zkp_musig_session_signer_data,
        nonce: *const secp256k1_zkp_pubkey,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Updates a session with the combined public nonce of all signers. The combined"]
    #[doc = " public nonce is the sum of every signer's public nonce."]
    #[doc = ""]
    #[doc = "  Returns: 1: nonces are successfully combined"]
    #[doc = "           0: a signer's nonce is missing"]
    #[doc = "  Args:        ctx: pointer to a context object (cannot be NULL)"]
    #[doc = "           session: session to update with the combined public nonce (cannot be"]
    #[doc = "                    NULL)"]
    #[doc = "           signers: an array of signers' data, which must have had public nonces"]
    #[doc = "                    set with `musig_set_nonce`. Array length must equal to `n_signers`"]
    #[doc = "                    (cannot be NULL)"]
    #[doc = "         n_signers: the length of the signers array. Must be the total number of"]
    #[doc = "                    signers participating in the MuSig."]
    #[doc = "  Out: nonce_is_negated: a pointer to an integer that indicates if the combined"]
    #[doc = "                    public nonce had to be negated."]
    #[doc = "           adaptor: point to add to the combined public nonce. If NULL, nothing is"]
    #[doc = "                    added to the combined nonce."]
    pub fn secp256k1_zkp_musig_session_combine_nonces(
        ctx: *const secp256k1_zkp_context,
        session: *mut secp256k1_zkp_musig_session,
        signers: *const secp256k1_zkp_musig_session_signer_data,
        n_signers: size_t,
        nonce_is_negated: *mut ::std::os::raw::c_int,
        adaptor: *const secp256k1_zkp_pubkey,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Serialize a MuSig partial signature or adaptor signature"]
    #[doc = ""]
    #[doc = "  Returns: 1 when the signature could be serialized, 0 otherwise"]
    #[doc = "  Args:    ctx: a secp256k1 context object"]
    #[doc = "  Out:   out32: pointer to a 32-byte array to store the serialized signature"]
    #[doc = "  In:      sig: pointer to the signature"]
    pub fn secp256k1_zkp_musig_partial_signature_serialize(
        ctx: *const secp256k1_zkp_context,
        out32: *mut ::std::os::raw::c_uchar,
        sig: *const secp256k1_zkp_musig_partial_signature,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse and verify a MuSig partial signature."]
    #[doc = ""]
    #[doc = "  Returns: 1 when the signature could be parsed, 0 otherwise."]
    #[doc = "  Args:    ctx: a secp256k1 context object"]
    #[doc = "  Out:     sig: pointer to a signature object"]
    #[doc = "  In:     in32: pointer to the 32-byte signature to be parsed"]
    #[doc = ""]
    #[doc = "  After the call, sig will always be initialized. If parsing failed or the"]
    #[doc = "  encoded numbers are out of range, signature verification with it is"]
    #[doc = "  guaranteed to fail for every message and public key."]
    pub fn secp256k1_zkp_musig_partial_signature_parse(
        ctx: *const secp256k1_zkp_context,
        sig: *mut secp256k1_zkp_musig_partial_signature,
        in32: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Produces a partial signature"]
    #[doc = ""]
    #[doc = "  Returns: 1: partial signature constructed"]
    #[doc = "           0: session in incorrect or inconsistent state"]
    #[doc = "  Args:         ctx: pointer to a context object (cannot be NULL)"]
    #[doc = "            session: active signing session for which the combined nonce has been"]
    #[doc = "                     computed (cannot be NULL)"]
    #[doc = "  Out:  partial_sig: partial signature (cannot be NULL)"]
    pub fn secp256k1_zkp_musig_partial_sign(
        ctx: *const secp256k1_zkp_context,
        session: *const secp256k1_zkp_musig_session,
        partial_sig: *mut secp256k1_zkp_musig_partial_signature,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks that an individual partial signature verifies"]
    #[doc = ""]
    #[doc = "  This function is essential when using protocols with adaptor signatures."]
    #[doc = "  However, it is not essential for regular MuSig's, in the sense that if any"]
    #[doc = "  partial signatures does not verify, the full signature will also not verify, so the"]
    #[doc = "  problem will be caught. But this function allows determining the specific party"]
    #[doc = "  who produced an invalid signature, so that signing can be restarted without them."]
    #[doc = ""]
    #[doc = "  Returns: 1: partial signature verifies"]
    #[doc = "           0: invalid signature or bad data"]
    #[doc = "  Args:         ctx: pointer to a context object (cannot be NULL)"]
    #[doc = "            session: active session for which the combined nonce has been computed"]
    #[doc = "                     (cannot be NULL)"]
    #[doc = "             signer: data for the signer who produced this signature (cannot be NULL)"]
    #[doc = "  In:   partial_sig: signature to verify (cannot be NULL)"]
    #[doc = "             pubkey: public key of the signer who produced the signature (cannot be NULL)"]
    pub fn secp256k1_zkp_musig_partial_sig_verify(
        ctx: *const secp256k1_zkp_context,
        session: *const secp256k1_zkp_musig_session,
        signer: *const secp256k1_zkp_musig_session_signer_data,
        partial_sig: *const secp256k1_zkp_musig_partial_signature,
        pubkey: *const secp256k1_zkp_xonly_pubkey,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Combines partial signatures"]
    #[doc = ""]
    #[doc = "  Returns: 1: all partial signatures have values in range. Does NOT mean the"]
    #[doc = "              resulting signature verifies."]
    #[doc = "           0: some partial signature had s/r out of range"]
    #[doc = "  Args:         ctx: pointer to a context object (cannot be NULL)"]
    #[doc = "            session: initialized session for which the combined nonce has been"]
    #[doc = "                     computed (cannot be NULL)"]
    #[doc = "  Out:        sig64: complete signature (cannot be NULL)"]
    #[doc = "  In:  partial_sigs: array of partial signatures to combine (cannot be NULL)"]
    #[doc = "             n_sigs: number of signatures in the partial_sigs array"]
    pub fn secp256k1_zkp_musig_partial_sig_combine(
        ctx: *const secp256k1_zkp_context,
        session: *const secp256k1_zkp_musig_session,
        sig64: *mut ::std::os::raw::c_uchar,
        partial_sigs: *const secp256k1_zkp_musig_partial_signature,
        n_sigs: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts a partial signature to an adaptor signature by adding a given secret"]
    #[doc = "  adaptor."]
    #[doc = ""]
    #[doc = "  Returns: 1: signature and secret adaptor contained valid values"]
    #[doc = "           0: otherwise"]
    #[doc = "  Args:         ctx: pointer to a context object (cannot be NULL)"]
    #[doc = "  Out:  adaptor_sig: adaptor signature to produce (cannot be NULL)"]
    #[doc = "  In:   partial_sig: partial signature to tweak with secret adaptor (cannot be NULL)"]
    #[doc = "      sec_adaptor32: 32-byte secret adaptor to add to the partial signature (cannot"]
    #[doc = "                     be NULL)"]
    #[doc = "   nonce_is_negated: the `nonce_is_negated` output of `musig_session_combine_nonces`"]
    pub fn secp256k1_zkp_musig_partial_sig_adapt(
        ctx: *const secp256k1_zkp_context,
        adaptor_sig: *mut secp256k1_zkp_musig_partial_signature,
        partial_sig: *const secp256k1_zkp_musig_partial_signature,
        sec_adaptor32: *const ::std::os::raw::c_uchar,
        nonce_is_negated: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Extracts a secret adaptor from a MuSig, given all parties' partial"]
    #[doc = "  signatures. This function will not fail unless given grossly invalid data; if it"]
    #[doc = "  is merely given signatures that do not verify, the returned value will be"]
    #[doc = "  nonsense. It is therefore important that all data be verified at earlier steps of"]
    #[doc = "  any protocol that uses this function."]
    #[doc = ""]
    #[doc = "  Returns: 1: signatures contained valid data such that an adaptor could be extracted"]
    #[doc = "           0: otherwise"]
    #[doc = "  Args:         ctx: pointer to a context object (cannot be NULL)"]
    #[doc = "  Out:sec_adaptor32: 32-byte secret adaptor (cannot be NULL)"]
    #[doc = "  In:         sig64: complete 2-of-2 signature (cannot be NULL)"]
    #[doc = "       partial_sigs: array of partial signatures (cannot be NULL)"]
    #[doc = "     n_partial_sigs: number of elements in partial_sigs array"]
    #[doc = "   nonce_is_negated: the `nonce_is_negated` output of `musig_session_combine_nonces`"]
    pub fn secp256k1_zkp_musig_extract_secret_adaptor(
        ctx: *const secp256k1_zkp_context,
        sec_adaptor32: *mut ::std::os::raw::c_uchar,
        sig64: *const ::std::os::raw::c_uchar,
        partial_sigs: *const secp256k1_zkp_musig_partial_signature,
        n_partial_sigs: size_t,
        nonce_is_negated: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine the memory size of a secp256k1 context object to be created in"]
    #[doc = "  caller-provided memory."]
    #[doc = ""]
    #[doc = "  The purpose of this function is to determine how much memory must be provided"]
    #[doc = "  to secp256k1_zkp_context_preallocated_create."]
    #[doc = ""]
    #[doc = "  Returns: the required size of the caller-provided memory block"]
    #[doc = "  In:      flags:    which parts of the context to initialize."]
    pub fn secp256k1_zkp_context_preallocated_size(flags: ::std::os::raw::c_uint) -> size_t;
}
extern "C" {
    #[doc = " Create a secp256k1 context object in caller-provided memory."]
    #[doc = ""]
    #[doc = "  The caller must provide a pointer to a rewritable contiguous block of memory"]
    #[doc = "  of size at least secp256k1_zkp_context_preallocated_size(flags) bytes, suitably"]
    #[doc = "  aligned to hold an object of any type."]
    #[doc = ""]
    #[doc = "  The block of memory is exclusively owned by the created context object during"]
    #[doc = "  the lifetime of this context object, which begins with the call to this"]
    #[doc = "  function and ends when a call to secp256k1_zkp_context_preallocated_destroy"]
    #[doc = "  (which destroys the context object again) returns. During the lifetime of the"]
    #[doc = "  context object, the caller is obligated not to access this block of memory,"]
    #[doc = "  i.e., the caller may not read or write the memory, e.g., by copying the memory"]
    #[doc = "  contents to a different location or trying to create a second context object"]
    #[doc = "  in the memory. In simpler words, the prealloc pointer (or any pointer derived"]
    #[doc = "  from it) should not be used during the lifetime of the context object."]
    #[doc = ""]
    #[doc = "  Returns: a newly created context object."]
    #[doc = "  In:      prealloc: a pointer to a rewritable contiguous block of memory of"]
    #[doc = "                     size at least secp256k1_zkp_context_preallocated_size(flags)"]
    #[doc = "                     bytes, as detailed above (cannot be NULL)"]
    #[doc = "           flags:    which parts of the context to initialize."]
    #[doc = ""]
    #[doc = "  See also secp256k1_zkp_context_randomize (in secp256k1.h)"]
    #[doc = "  and secp256k1_zkp_context_preallocated_destroy."]
    pub fn secp256k1_zkp_context_preallocated_create(
        prealloc: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> *mut secp256k1_zkp_context;
}
extern "C" {
    #[doc = " Determine the memory size of a secp256k1 context object to be copied into"]
    #[doc = "  caller-provided memory."]
    #[doc = ""]
    #[doc = "  Returns: the required size of the caller-provided memory block."]
    #[doc = "  In:      ctx: an existing context to copy (cannot be NULL)"]
    pub fn secp256k1_zkp_context_preallocated_clone_size(
        ctx: *const secp256k1_zkp_context,
    ) -> size_t;
}
extern "C" {
    #[doc = " Copy a secp256k1 context object into caller-provided memory."]
    #[doc = ""]
    #[doc = "  The caller must provide a pointer to a rewritable contiguous block of memory"]
    #[doc = "  of size at least secp256k1_zkp_context_preallocated_size(flags) bytes, suitably"]
    #[doc = "  aligned to hold an object of any type."]
    #[doc = ""]
    #[doc = "  The block of memory is exclusively owned by the created context object during"]
    #[doc = "  the lifetime of this context object, see the description of"]
    #[doc = "  secp256k1_zkp_context_preallocated_create for details."]
    #[doc = ""]
    #[doc = "  Returns: a newly created context object."]
    #[doc = "  Args:    ctx:      an existing context to copy (cannot be NULL)"]
    #[doc = "  In:      prealloc: a pointer to a rewritable contiguous block of memory of"]
    #[doc = "                     size at least secp256k1_zkp_context_preallocated_size(flags)"]
    #[doc = "                     bytes, as detailed above (cannot be NULL)"]
    pub fn secp256k1_zkp_context_preallocated_clone(
        ctx: *const secp256k1_zkp_context,
        prealloc: *mut ::std::os::raw::c_void,
    ) -> *mut secp256k1_zkp_context;
}
extern "C" {
    #[doc = " Destroy a secp256k1 context object that has been created in"]
    #[doc = "  caller-provided memory."]
    #[doc = ""]
    #[doc = "  The context pointer may not be used afterwards."]
    #[doc = ""]
    #[doc = "  The context to destroy must have been created using"]
    #[doc = "  secp256k1_zkp_context_preallocated_create or secp256k1_zkp_context_preallocated_clone."]
    #[doc = "  If the context has instead been created using secp256k1_zkp_context_create or"]
    #[doc = "  secp256k1_zkp_context_clone, the behaviour is undefined. In that case,"]
    #[doc = "  secp256k1_zkp_context_destroy must be used instead."]
    #[doc = ""]
    #[doc = "  If required, it is the responsibility of the caller to deallocate the block"]
    #[doc = "  of memory properly after this function returns, e.g., by calling free on the"]
    #[doc = "  preallocated pointer given to secp256k1_zkp_context_preallocated_create or"]
    #[doc = "  secp256k1_zkp_context_preallocated_clone."]
    #[doc = ""]
    #[doc = "  Args:   ctx: an existing context to destroy, constructed using"]
    #[doc = "               secp256k1_zkp_context_preallocated_create or"]
    #[doc = "               secp256k1_zkp_context_preallocated_clone (cannot be NULL)"]
    pub fn secp256k1_zkp_context_preallocated_destroy(ctx: *mut secp256k1_zkp_context);
}
#[doc = " Opaque data structure that stores a Pedersen commitment"]
#[doc = ""]
#[doc = "  The exact representation of data inside is implementation defined and not"]
#[doc = "  guaranteed to be portable between different platforms or versions. It is"]
#[doc = "  however guaranteed to be 64 bytes in size, and can be safely copied/moved."]
#[doc = "  If you need to convert to a format suitable for storage, transmission, or"]
#[doc = "  comparison, use secp256k1_zkp_pedersen_commitment_serialize and"]
#[doc = "  secp256k1_zkp_pedersen_commitment_parse."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct secp256k1_zkp_pedersen_commitment {
    pub data: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_secp256k1_zkp_pedersen_commitment() {
    assert_eq!(
        ::std::mem::size_of::<secp256k1_zkp_pedersen_commitment>(),
        64usize,
        concat!("Size of: ", stringify!(secp256k1_zkp_pedersen_commitment))
    );
    assert_eq!(
        ::std::mem::align_of::<secp256k1_zkp_pedersen_commitment>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(secp256k1_zkp_pedersen_commitment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_pedersen_commitment>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_pedersen_commitment),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub static mut secp256k1_zkp_generator_h: *const secp256k1_zkp_generator;
}
extern "C" {
    #[doc = " Parse a 33-byte commitment into a commitment object."]
    #[doc = ""]
    #[doc = "  Returns: 1 if input contains a valid commitment."]
    #[doc = "  Args: ctx:      a secp256k1 context object."]
    #[doc = "  Out:  commit:   pointer to the output commitment object"]
    #[doc = "  In:   input:    pointer to a 33-byte serialized commitment key"]
    pub fn secp256k1_zkp_pedersen_commitment_parse(
        ctx: *const secp256k1_zkp_context,
        commit: *mut secp256k1_zkp_pedersen_commitment,
        input: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Serialize a commitment object into a serialized byte sequence."]
    #[doc = ""]
    #[doc = "  Returns: 1 always."]
    #[doc = "  Args:   ctx:        a secp256k1 context object."]
    #[doc = "  Out:    output:     a pointer to a 33-byte byte array"]
    #[doc = "  In:     commit:     a pointer to a secp256k1_zkp_pedersen_commitment containing an"]
    #[doc = "                      initialized commitment"]
    pub fn secp256k1_zkp_pedersen_commitment_serialize(
        ctx: *const secp256k1_zkp_context,
        output: *mut ::std::os::raw::c_uchar,
        commit: *const secp256k1_zkp_pedersen_commitment,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize a context for usage with Pedersen commitments."]
    pub fn secp256k1_zkp_pedersen_context_initialize(ctx: *mut secp256k1_zkp_context);
}
extern "C" {
    #[doc = " Generate a pedersen commitment."]
    #[doc = "  Returns 1: Commitment successfully created."]
    #[doc = "          0: Error. The blinding factor is larger than the group order"]
    #[doc = "             (probability for random 32 byte number < 2^-127) or results in the"]
    #[doc = "             point at infinity. Retry with a different factor."]
    #[doc = "  In:     ctx:        pointer to a context object, initialized for signing and Pedersen commitment (cannot be NULL)"]
    #[doc = "          blind:      pointer to a 32-byte blinding factor (cannot be NULL)"]
    #[doc = "          value:      unsigned 64-bit integer value to commit to."]
    #[doc = "          gen:        additional generator 'h'"]
    #[doc = "  Out:    commit:     pointer to the commitment (cannot be NULL)"]
    #[doc = ""]
    #[doc = "  Blinding factors can be generated and verified in the same way as secp256k1 private keys for ECDSA."]
    pub fn secp256k1_zkp_pedersen_commit(
        ctx: *const secp256k1_zkp_context,
        commit: *mut secp256k1_zkp_pedersen_commitment,
        blind: *const ::std::os::raw::c_uchar,
        value: u64,
        gen: *const secp256k1_zkp_generator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes the sum of multiple positive and negative blinding factors."]
    #[doc = "  Returns 1: Sum successfully computed."]
    #[doc = "          0: Error. A blinding factor is larger than the group order"]
    #[doc = "             (probability for random 32 byte number < 2^-127). Retry with"]
    #[doc = "             different factors."]
    #[doc = "  In:     ctx:        pointer to a context object (cannot be NULL)"]
    #[doc = "          blinds:     pointer to pointers to 32-byte character arrays for blinding factors. (cannot be NULL)"]
    #[doc = "          n:          number of factors pointed to by blinds."]
    #[doc = "          npositive:       how many of the initial factors should be treated with a positive sign."]
    #[doc = "  Out:    blind_out:  pointer to a 32-byte array for the sum (cannot be NULL)"]
    pub fn secp256k1_zkp_pedersen_blind_sum(
        ctx: *const secp256k1_zkp_context,
        blind_out: *mut ::std::os::raw::c_uchar,
        blinds: *const *const ::std::os::raw::c_uchar,
        n: size_t,
        npositive: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Verify a tally of pedersen commitments"]
    #[doc = " Returns 1: commitments successfully sum to zero."]
    #[doc = "         0: Commitments do not sum to zero or other error."]
    #[doc = " In:     ctx:        pointer to a context object (cannot be NULL)"]
    #[doc = "         commits:    pointer to array of pointers to the commitments. (cannot be NULL if pcnt is non-zero)"]
    #[doc = "         pcnt:       number of commitments pointed to by commits."]
    #[doc = "         ncommits:   pointer to array of pointers to the negative commitments. (cannot be NULL if ncnt is non-zero)"]
    #[doc = "         ncnt:       number of commitments pointed to by ncommits."]
    #[doc = ""]
    #[doc = " This computes sum(commit[0..pcnt)) - sum(ncommit[0..ncnt)) == 0."]
    #[doc = ""]
    #[doc = " A pedersen commitment is xG + vA where G and A are generators for the secp256k1 group and x is a blinding factor,"]
    #[doc = " while v is the committed value. For a collection of commitments to sum to zero, for each distinct generator"]
    #[doc = " A all blinding factors and all values must sum to zero."]
    #[doc = ""]
    pub fn secp256k1_zkp_pedersen_verify_tally(
        ctx: *const secp256k1_zkp_context,
        commits: *const *const secp256k1_zkp_pedersen_commitment,
        pcnt: size_t,
        ncommits: *const *const secp256k1_zkp_pedersen_commitment,
        ncnt: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the final Pedersen blinding factor correctly when the generators themselves"]
    #[doc = "  have blinding factors."]
    #[doc = ""]
    #[doc = " Consider a generator of the form A' = A + rG, where A is the \"real\" generator"]
    #[doc = " but A' is the generator provided to verifiers. Then a Pedersen commitment"]
    #[doc = " P = vA' + r'G really has the form vA + (vr + r')G. To get all these (vr + r')"]
    #[doc = " to sum to zero for multiple commitments, we take three arrays consisting of"]
    #[doc = " the `v`s, `r`s, and `r'`s, respectively called `value`s, `generator_blind`s"]
    #[doc = " and `blinding_factor`s, and sum them."]
    #[doc = ""]
    #[doc = " The function then subtracts the sum of all (vr + r') from the last element"]
    #[doc = " of the `blinding_factor` array, setting the total sum to zero."]
    #[doc = ""]
    #[doc = " Returns 1: Blinding factor successfully computed."]
    #[doc = "         0: Error. A blinding_factor or generator_blind are larger than the group"]
    #[doc = "            order (probability for random 32 byte number < 2^-127). Retry with"]
    #[doc = "            different values."]
    #[doc = ""]
    #[doc = " In:                 ctx: pointer to a context object"]
    #[doc = "                   value: array of asset values, `v` in the above paragraph."]
    #[doc = "                          May not be NULL unless `n_total` is 0."]
    #[doc = "         generator_blind: array of asset blinding factors, `r` in the above paragraph"]
    #[doc = "                          May not be NULL unless `n_total` is 0."]
    #[doc = "                 n_total: Total size of the above arrays"]
    #[doc = "                n_inputs: How many of the initial array elements represent commitments that"]
    #[doc = "                          will be negated in the final sum"]
    #[doc = " In/Out: blinding_factor: array of commitment blinding factors, `r'` in the above paragraph"]
    #[doc = "                          May not be NULL unless `n_total` is 0."]
    #[doc = "                          the last value will be modified to get the total sum to zero."]
    pub fn secp256k1_zkp_pedersen_blind_generator_blind_sum(
        ctx: *const secp256k1_zkp_context,
        value: *const u64,
        generator_blind: *const *const ::std::os::raw::c_uchar,
        blinding_factor: *const *mut ::std::os::raw::c_uchar,
        n_total: size_t,
        n_inputs: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize a context for usage with Pedersen commitments."]
    pub fn secp256k1_zkp_rangeproof_context_initialize(ctx: *mut secp256k1_zkp_context);
}
extern "C" {
    #[doc = " Verify a proof that a committed value is within a range."]
    #[doc = " Returns 1: Value is within the range [0..2^64), the specifically proven range is in the min/max value outputs."]
    #[doc = "         0: Proof failed or other error."]
    #[doc = " In:   ctx: pointer to a context object, initialized for range-proof and commitment (cannot be NULL)"]
    #[doc = "       commit: the commitment being proved. (cannot be NULL)"]
    #[doc = "       proof: pointer to character array with the proof. (cannot be NULL)"]
    #[doc = "       plen: length of proof in bytes."]
    #[doc = "       extra_commit: additional data covered in rangeproof signature"]
    #[doc = "       extra_commit_len: length of extra_commit byte array (0 if NULL)"]
    #[doc = "       gen: additional generator 'h'"]
    #[doc = " Out:  min_value: pointer to a unsigned int64 which will be updated with the minimum value that commit could have. (cannot be NULL)"]
    #[doc = "       max_value: pointer to a unsigned int64 which will be updated with the maximum value that commit could have. (cannot be NULL)"]
    pub fn secp256k1_zkp_rangeproof_verify(
        ctx: *const secp256k1_zkp_context,
        min_value: *mut u64,
        max_value: *mut u64,
        commit: *const secp256k1_zkp_pedersen_commitment,
        proof: *const ::std::os::raw::c_uchar,
        plen: size_t,
        extra_commit: *const ::std::os::raw::c_uchar,
        extra_commit_len: size_t,
        gen: *const secp256k1_zkp_generator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Verify a range proof proof and rewind the proof to recover information sent by its author."]
    #[doc = "  Returns 1: Value is within the range [0..2^64), the specifically proven range is in the min/max value outputs, and the value and blinding were recovered."]
    #[doc = "          0: Proof failed, rewind failed, or other error."]
    #[doc = "  In:   ctx: pointer to a context object, initialized for range-proof and Pedersen commitment (cannot be NULL)"]
    #[doc = "        commit: the commitment being proved. (cannot be NULL)"]
    #[doc = "        proof: pointer to character array with the proof. (cannot be NULL)"]
    #[doc = "        plen: length of proof in bytes."]
    #[doc = "        nonce: 32-byte secret nonce used by the prover (cannot be NULL)"]
    #[doc = "        extra_commit: additional data covered in rangeproof signature"]
    #[doc = "        extra_commit_len: length of extra_commit byte array (0 if NULL)"]
    #[doc = "        gen: additional generator 'h'"]
    #[doc = "  In/Out: blind_out: storage for the 32-byte blinding factor used for the commitment"]
    #[doc = "        value_out: pointer to an unsigned int64 which has the exact value of the commitment."]
    #[doc = "        message_out: pointer to a 4096 byte character array to receive message data from the proof author."]
    #[doc = "        outlen:  length of message data written to message_out."]
    #[doc = "        min_value: pointer to an unsigned int64 which will be updated with the minimum value that commit could have. (cannot be NULL)"]
    #[doc = "        max_value: pointer to an unsigned int64 which will be updated with the maximum value that commit could have. (cannot be NULL)"]
    pub fn secp256k1_zkp_rangeproof_rewind(
        ctx: *const secp256k1_zkp_context,
        blind_out: *mut ::std::os::raw::c_uchar,
        value_out: *mut u64,
        message_out: *mut ::std::os::raw::c_uchar,
        outlen: *mut size_t,
        nonce: *const ::std::os::raw::c_uchar,
        min_value: *mut u64,
        max_value: *mut u64,
        commit: *const secp256k1_zkp_pedersen_commitment,
        proof: *const ::std::os::raw::c_uchar,
        plen: size_t,
        extra_commit: *const ::std::os::raw::c_uchar,
        extra_commit_len: size_t,
        gen: *const secp256k1_zkp_generator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Author a proof that a committed value is within a range."]
    #[doc = "  Returns 1: Proof successfully created."]
    #[doc = "          0: Error"]
    #[doc = "  In:     ctx:    pointer to a context object, initialized for range-proof, signing, and Pedersen commitment (cannot be NULL)"]
    #[doc = "          proof:  pointer to array to receive the proof, can be up to 5134 bytes. (cannot be NULL)"]
    #[doc = "          min_value: constructs a proof where the verifer can tell the minimum value is at least the specified amount."]
    #[doc = "          commit: the commitment being proved."]
    #[doc = "          blind:  32-byte blinding factor used by commit."]
    #[doc = "          nonce:  32-byte secret nonce used to initialize the proof (value can be reverse-engineered out of the proof if this secret is known.)"]
    #[doc = "          exp:    Base-10 exponent. Digits below above will be made public, but the proof will be made smaller. Allowed range is -1 to 18."]
    #[doc = "                  (-1 is a special case that makes the value public. 0 is the most private.)"]
    #[doc = "          min_bits: Number of bits of the value to keep private. (0 = auto/minimal, - 64)."]
    #[doc = "          value:  Actual value of the commitment."]
    #[doc = "          message: pointer to a byte array of data to be embedded in the rangeproof that can be recovered by rewinding the proof"]
    #[doc = "          msg_len: size of the message to be embedded in the rangeproof"]
    #[doc = "          extra_commit: additional data to be covered in rangeproof signature"]
    #[doc = "          extra_commit_len: length of extra_commit byte array (0 if NULL)"]
    #[doc = "          gen: additional generator 'h'"]
    #[doc = "  In/out: plen:   point to an integer with the size of the proof buffer and the size of the constructed proof."]
    #[doc = ""]
    #[doc = "  If min_value or exp is non-zero then the value must be on the range [0, 2^63) to prevent the proof range from spanning past 2^64."]
    #[doc = ""]
    #[doc = "  If exp is -1 the value is revealed by the proof (e.g. it proves that the proof is a blinding of a specific value, without revealing the blinding key.)"]
    #[doc = ""]
    #[doc = "  This can randomly fail with probability around one in 2^100. If this happens, buy a lottery ticket and retry with a different nonce or blinding."]
    #[doc = ""]
    pub fn secp256k1_zkp_rangeproof_sign(
        ctx: *const secp256k1_zkp_context,
        proof: *mut ::std::os::raw::c_uchar,
        plen: *mut size_t,
        min_value: u64,
        commit: *const secp256k1_zkp_pedersen_commitment,
        blind: *const ::std::os::raw::c_uchar,
        nonce: *const ::std::os::raw::c_uchar,
        exp: ::std::os::raw::c_int,
        min_bits: ::std::os::raw::c_int,
        value: u64,
        message: *const ::std::os::raw::c_uchar,
        msg_len: size_t,
        extra_commit: *const ::std::os::raw::c_uchar,
        extra_commit_len: size_t,
        gen: *const secp256k1_zkp_generator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Extract some basic information from a range-proof."]
    #[doc = "  Returns 1: Information successfully extracted."]
    #[doc = "          0: Decode failed."]
    #[doc = "  In:   ctx: pointer to a context object"]
    #[doc = "        proof: pointer to character array with the proof."]
    #[doc = "        plen: length of proof in bytes."]
    #[doc = "  Out:  exp: Exponent used in the proof (-1 means the value isn't private)."]
    #[doc = "        mantissa: Number of bits covered by the proof."]
    #[doc = "        min_value: pointer to an unsigned int64 which will be updated with the minimum value that commit could have. (cannot be NULL)"]
    #[doc = "        max_value: pointer to an unsigned int64 which will be updated with the maximum value that commit could have. (cannot be NULL)"]
    pub fn secp256k1_zkp_rangeproof_info(
        ctx: *const secp256k1_zkp_context,
        exp: *mut ::std::os::raw::c_int,
        mantissa: *mut ::std::os::raw::c_int,
        min_value: *mut u64,
        max_value: *mut u64,
        proof: *const ::std::os::raw::c_uchar,
        plen: size_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Opaque data structured that holds a parsed ECDSA signature,"]
#[doc = "  supporting pubkey recovery."]
#[doc = ""]
#[doc = "  The exact representation of data inside is implementation defined and not"]
#[doc = "  guaranteed to be portable between different platforms or versions. It is"]
#[doc = "  however guaranteed to be 65 bytes in size, and can be safely copied/moved."]
#[doc = "  If you need to convert to a format suitable for storage or transmission, use"]
#[doc = "  the secp256k1_zkp_ecdsa_signature_serialize_* and"]
#[doc = "  secp256k1_zkp_ecdsa_signature_parse_* functions."]
#[doc = ""]
#[doc = "  Furthermore, it is guaranteed that identical signatures (including their"]
#[doc = "  recoverability) will have identical representation, so they can be"]
#[doc = "  memcmp'ed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct secp256k1_zkp_ecdsa_recoverable_signature {
    pub data: [::std::os::raw::c_uchar; 65usize],
}
#[test]
fn bindgen_test_layout_secp256k1_zkp_ecdsa_recoverable_signature() {
    assert_eq!(
        ::std::mem::size_of::<secp256k1_zkp_ecdsa_recoverable_signature>(),
        65usize,
        concat!(
            "Size of: ",
            stringify!(secp256k1_zkp_ecdsa_recoverable_signature)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<secp256k1_zkp_ecdsa_recoverable_signature>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(secp256k1_zkp_ecdsa_recoverable_signature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_ecdsa_recoverable_signature>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_ecdsa_recoverable_signature),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Parse a compact ECDSA signature (64 bytes + recovery id)."]
    #[doc = ""]
    #[doc = "  Returns: 1 when the signature could be parsed, 0 otherwise"]
    #[doc = "  Args: ctx:     a secp256k1 context object"]
    #[doc = "  Out:  sig:     a pointer to a signature object"]
    #[doc = "  In:   input64: a pointer to a 64-byte compact signature"]
    #[doc = "        recid:   the recovery id (0, 1, 2 or 3)"]
    pub fn secp256k1_zkp_ecdsa_recoverable_signature_parse_compact(
        ctx: *const secp256k1_zkp_context,
        sig: *mut secp256k1_zkp_ecdsa_recoverable_signature,
        input64: *const ::std::os::raw::c_uchar,
        recid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a recoverable signature into a normal signature."]
    #[doc = ""]
    #[doc = "  Returns: 1"]
    #[doc = "  Out: sig:    a pointer to a normal signature (cannot be NULL)."]
    #[doc = "  In:  sigin:  a pointer to a recoverable signature (cannot be NULL)."]
    pub fn secp256k1_zkp_ecdsa_recoverable_signature_convert(
        ctx: *const secp256k1_zkp_context,
        sig: *mut secp256k1_zkp_ecdsa_signature,
        sigin: *const secp256k1_zkp_ecdsa_recoverable_signature,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Serialize an ECDSA signature in compact format (64 bytes + recovery id)."]
    #[doc = ""]
    #[doc = "  Returns: 1"]
    #[doc = "  Args: ctx:      a secp256k1 context object"]
    #[doc = "  Out:  output64: a pointer to a 64-byte array of the compact signature (cannot be NULL)"]
    #[doc = "        recid:    a pointer to an integer to hold the recovery id (can be NULL)."]
    #[doc = "  In:   sig:      a pointer to an initialized signature object (cannot be NULL)"]
    pub fn secp256k1_zkp_ecdsa_recoverable_signature_serialize_compact(
        ctx: *const secp256k1_zkp_context,
        output64: *mut ::std::os::raw::c_uchar,
        recid: *mut ::std::os::raw::c_int,
        sig: *const secp256k1_zkp_ecdsa_recoverable_signature,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a recoverable ECDSA signature."]
    #[doc = ""]
    #[doc = "  Returns: 1: signature created"]
    #[doc = "           0: the nonce generation function failed, or the secret key was invalid."]
    #[doc = "  Args:    ctx:    pointer to a context object, initialized for signing (cannot be NULL)"]
    #[doc = "  Out:     sig:    pointer to an array where the signature will be placed (cannot be NULL)"]
    #[doc = "  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)"]
    #[doc = "           seckey: pointer to a 32-byte secret key (cannot be NULL)"]
    #[doc = "           noncefp:pointer to a nonce generation function. If NULL, secp256k1_zkp_nonce_function_default is used"]
    #[doc = "           ndata:  pointer to arbitrary data used by the nonce generation function (can be NULL)"]
    pub fn secp256k1_zkp_ecdsa_sign_recoverable(
        ctx: *const secp256k1_zkp_context,
        sig: *mut secp256k1_zkp_ecdsa_recoverable_signature,
        msg32: *const ::std::os::raw::c_uchar,
        seckey: *const ::std::os::raw::c_uchar,
        noncefp: secp256k1_zkp_nonce_function,
        ndata: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Recover an ECDSA public key from a signature."]
    #[doc = ""]
    #[doc = "  Returns: 1: public key successfully recovered (which guarantees a correct signature)."]
    #[doc = "           0: otherwise."]
    #[doc = "  Args:    ctx:        pointer to a context object, initialized for verification (cannot be NULL)"]
    #[doc = "  Out:     pubkey:     pointer to the recovered public key (cannot be NULL)"]
    #[doc = "  In:      sig:        pointer to initialized signature that supports pubkey recovery (cannot be NULL)"]
    #[doc = "           msg32:      the 32-byte message hash assumed to be signed (cannot be NULL)"]
    pub fn secp256k1_zkp_ecdsa_recover(
        ctx: *const secp256k1_zkp_context,
        pubkey: *mut secp256k1_zkp_pubkey,
        sig: *const secp256k1_zkp_ecdsa_recoverable_signature,
        msg32: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A pointer to a function to deterministically generate a nonce."]
#[doc = ""]
#[doc = "  Same as secp256k1_zkp_nonce function with the exception of accepting an"]
#[doc = "  additional pubkey argument and not requiring an attempt argument. The pubkey"]
#[doc = "  argument can protect signature schemes with key-prefixed challenge hash"]
#[doc = "  inputs against reusing the nonce when signing with the wrong precomputed"]
#[doc = "  pubkey."]
#[doc = ""]
#[doc = "  Returns: 1 if a nonce was successfully generated. 0 will cause signing to"]
#[doc = "           return an error."]
#[doc = "  Out:     nonce32:   pointer to a 32-byte array to be filled by the function."]
#[doc = "  In:      msg32:     the 32-byte message hash being verified (will not be NULL)"]
#[doc = "           key32:     pointer to a 32-byte secret key (will not be NULL)"]
#[doc = "      xonly_pk32:     the 32-byte serialized xonly pubkey corresponding to key32"]
#[doc = "                      (will not be NULL)"]
#[doc = "           algo16:    pointer to a 16-byte array describing the signature"]
#[doc = "                      algorithm (will not be NULL)."]
#[doc = "           data:      Arbitrary data pointer that is passed through."]
#[doc = ""]
#[doc = "  Except for test cases, this function should compute some cryptographic hash of"]
#[doc = "  the message, the key, the pubkey, the algorithm description, and data."]
pub type secp256k1_zkp_nonce_function_hardened = ::std::option::Option<
    unsafe extern "C" fn(
        nonce32: *mut ::std::os::raw::c_uchar,
        msg32: *const ::std::os::raw::c_uchar,
        key32: *const ::std::os::raw::c_uchar,
        xonly_pk32: *const ::std::os::raw::c_uchar,
        algo16: *const ::std::os::raw::c_uchar,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub static secp256k1_zkp_nonce_function_bip340: secp256k1_zkp_nonce_function_hardened;
}
extern "C" {
    #[doc = " Create a Schnorr signature."]
    #[doc = ""]
    #[doc = "  Does _not_ strictly follow BIP-340 because it does not verify the resulting"]
    #[doc = "  signature. Instead, you can manually use secp256k1_zkp_schnorrsig_verify and"]
    #[doc = "  abort if it fails."]
    #[doc = ""]
    #[doc = "  Otherwise BIP-340 compliant if the noncefp argument is NULL or"]
    #[doc = "  secp256k1_zkp_nonce_function_bip340 and the ndata argument is 32-byte auxiliary"]
    #[doc = "  randomness."]
    #[doc = ""]
    #[doc = "  Returns 1 on success, 0 on failure."]
    #[doc = "  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)"]
    #[doc = "  Out:   sig64: pointer to a 64-byte array to store the serialized signature (cannot be NULL)"]
    #[doc = "  In:    msg32: the 32-byte message being signed (cannot be NULL)"]
    #[doc = "       keypair: pointer to an initialized keypair (cannot be NULL)"]
    #[doc = "       noncefp: pointer to a nonce generation function. If NULL, secp256k1_zkp_nonce_function_bip340 is used"]
    #[doc = "         ndata: pointer to arbitrary data used by the nonce generation"]
    #[doc = "                function (can be NULL). If it is non-NULL and"]
    #[doc = "                secp256k1_zkp_nonce_function_bip340 is used, then ndata must be a"]
    #[doc = "                pointer to 32-byte auxiliary randomness as per BIP-340."]
    pub fn secp256k1_zkp_schnorrsig_sign(
        ctx: *const secp256k1_zkp_context,
        sig64: *mut ::std::os::raw::c_uchar,
        msg32: *const ::std::os::raw::c_uchar,
        keypair: *const secp256k1_zkp_keypair,
        noncefp: secp256k1_zkp_nonce_function_hardened,
        ndata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Verify a Schnorr signature."]
    #[doc = ""]
    #[doc = "  Returns: 1: correct signature"]
    #[doc = "           0: incorrect signature"]
    #[doc = "  Args:    ctx: a secp256k1 context object, initialized for verification."]
    #[doc = "  In:    sig64: pointer to the 64-byte signature to verify (cannot be NULL)"]
    #[doc = "         msg32: the 32-byte message being verified (cannot be NULL)"]
    #[doc = "        pubkey: pointer to an x-only public key to verify with (cannot be NULL)"]
    pub fn secp256k1_zkp_schnorrsig_verify(
        ctx: *const secp256k1_zkp_context,
        sig64: *const ::std::os::raw::c_uchar,
        msg32: *const ::std::os::raw::c_uchar,
        pubkey: *const secp256k1_zkp_xonly_pubkey,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Opaque data structure that holds a parsed surjection proof"]
#[doc = ""]
#[doc = "  The exact representation of data inside is implementation defined and not"]
#[doc = "  guaranteed to be portable between different platforms or versions. Nor is"]
#[doc = "  it guaranteed to have any particular size, nor that identical proofs"]
#[doc = "  will have identical representation. (That is, memcmp may return nonzero"]
#[doc = "  even for identical proofs.)"]
#[doc = ""]
#[doc = "  To obtain these properties, instead use secp256k1_zkp_surjectionproof_parse"]
#[doc = "  and secp256k1_zkp_surjectionproof_serialize to encode/decode proofs into a"]
#[doc = "  well-defined format."]
#[doc = ""]
#[doc = "  The representation is exposed to allow creation of these objects on the"]
#[doc = "  stack; please *do not* use these internals directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct secp256k1_zkp_surjectionproof {
    #[doc = " Total number of input asset tags"]
    pub n_inputs: size_t,
    #[doc = " Bitmap of which input tags are used in the surjection proof"]
    pub used_inputs: [::std::os::raw::c_uchar; 32usize],
    #[doc = " Borromean signature: e0, scalars"]
    pub data: [::std::os::raw::c_uchar; 8224usize],
}
#[test]
fn bindgen_test_layout_secp256k1_zkp_surjectionproof() {
    assert_eq!(
        ::std::mem::size_of::<secp256k1_zkp_surjectionproof>(),
        8264usize,
        concat!("Size of: ", stringify!(secp256k1_zkp_surjectionproof))
    );
    assert_eq!(
        ::std::mem::align_of::<secp256k1_zkp_surjectionproof>(),
        8usize,
        concat!("Alignment of ", stringify!(secp256k1_zkp_surjectionproof))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_surjectionproof>())).n_inputs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_surjectionproof),
            "::",
            stringify!(n_inputs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_surjectionproof>())).used_inputs as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_surjectionproof),
            "::",
            stringify!(used_inputs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_surjectionproof>())).data as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_surjectionproof),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Parse a surjection proof"]
    #[doc = ""]
    #[doc = "  Returns: 1 when the proof could be parsed, 0 otherwise."]
    #[doc = "  Args: ctx:    a secp256k1 context object"]
    #[doc = "  Out:  proof:  a pointer to a proof object"]
    #[doc = "  In:   input:  a pointer to the array to parse"]
    #[doc = "        inputlen: length of the array pointed to by input"]
    #[doc = ""]
    #[doc = "  The proof must consist of:"]
    #[doc = "    - A 2-byte little-endian total input count `n`"]
    #[doc = "    - A ceil(n/8)-byte bitmap indicating which inputs are used."]
    #[doc = "    - A big-endian 32-byte borromean signature e0 value"]
    #[doc = "    - `m` big-endian 32-byte borromean signature s values, where `m`"]
    #[doc = "      is the number of set bits in the bitmap"]
    pub fn secp256k1_zkp_surjectionproof_parse(
        ctx: *const secp256k1_zkp_context,
        proof: *mut secp256k1_zkp_surjectionproof,
        input: *const ::std::os::raw::c_uchar,
        inputlen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Serialize a surjection proof"]
    #[doc = ""]
    #[doc = "  Returns: 1 if enough space was available to serialize, 0 otherwise"]
    #[doc = "  Args:   ctx:        a secp256k1 context object"]
    #[doc = "  Out:    output:     a pointer to an array to store the serialization"]
    #[doc = "  In/Out: outputlen:  a pointer to an integer which is initially set to the"]
    #[doc = "                      size of output, and is overwritten with the written"]
    #[doc = "                      size."]
    #[doc = "  In:     proof:      a pointer to an initialized proof object"]
    #[doc = ""]
    #[doc = "  See secp256k1_zkp_surjectionproof_parse for details about the encoding."]
    pub fn secp256k1_zkp_surjectionproof_serialize(
        ctx: *const secp256k1_zkp_context,
        output: *mut ::std::os::raw::c_uchar,
        outputlen: *mut size_t,
        proof: *const secp256k1_zkp_surjectionproof,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Data structure that holds a fixed asset tag."]
#[doc = ""]
#[doc = " This data type is *not* opaque. It will always be 32 bytes of whatever"]
#[doc = " data the API user wants to use as an asset tag. Its contents have no"]
#[doc = " semantic meaning to libsecp whatsoever."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct secp256k1_zkp_fixed_asset_tag {
    pub data: [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_secp256k1_zkp_fixed_asset_tag() {
    assert_eq!(
        ::std::mem::size_of::<secp256k1_zkp_fixed_asset_tag>(),
        32usize,
        concat!("Size of: ", stringify!(secp256k1_zkp_fixed_asset_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<secp256k1_zkp_fixed_asset_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(secp256k1_zkp_fixed_asset_tag))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_fixed_asset_tag>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_fixed_asset_tag),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Returns the total number of inputs a proof expects to be over."]
    #[doc = ""]
    #[doc = " Returns: the number of inputs for the given proof"]
    #[doc = " In:   ctx: pointer to a context object"]
    #[doc = "     proof: a pointer to a proof object"]
    pub fn secp256k1_zkp_surjectionproof_n_total_inputs(
        ctx: *const secp256k1_zkp_context,
        proof: *const secp256k1_zkp_surjectionproof,
    ) -> size_t;
}
extern "C" {
    #[doc = " Returns the actual number of inputs that a proof uses"]
    #[doc = ""]
    #[doc = " Returns: the number of inputs for the given proof"]
    #[doc = " In:   ctx: pointer to a context object"]
    #[doc = "     proof: a pointer to a proof object"]
    pub fn secp256k1_zkp_surjectionproof_n_used_inputs(
        ctx: *const secp256k1_zkp_context,
        proof: *const secp256k1_zkp_surjectionproof,
    ) -> size_t;
}
extern "C" {
    #[doc = " Returns the total size this proof would take, in bytes, when serialized"]
    #[doc = ""]
    #[doc = " Returns: the total size"]
    #[doc = " In:   ctx: pointer to a context object"]
    #[doc = "     proof: a pointer to a proof object"]
    pub fn secp256k1_zkp_surjectionproof_serialized_size(
        ctx: *const secp256k1_zkp_context,
        proof: *const secp256k1_zkp_surjectionproof,
    ) -> size_t;
}
extern "C" {
    #[doc = " Surjection proof initialization function; decides on inputs to use"]
    #[doc = "  To be used to initialize stack-allocated secp256k1_zkp_surjectionproof struct"]
    #[doc = " Returns 0: inputs could not be selected"]
    #[doc = "         n: inputs were selected after n iterations of random selection"]
    #[doc = ""]
    #[doc = " In:               ctx: pointer to a context object"]
    #[doc = "      fixed_input_tags: fixed input tags `A_i` for all inputs. (If the fixed tag is not known,"]
    #[doc = "                        e.g. in a coinjoin with others' inputs, an ephemeral tag can be given;"]
    #[doc = "                        this won't match the output tag but might be used in the anonymity set.)"]
    #[doc = "          n_input_tags: the number of entries in the fixed_input_tags array"]
    #[doc = "   n_input_tags_to_use: the number of inputs to select randomly to put in the anonymity set"]
    #[doc = "                        Must be <= SECP256K1_SURJECTIONPROOF_MAX_USED_INPUTS"]
    #[doc = "      fixed_output_tag: fixed output tag"]
    #[doc = "      max_n_iterations: the maximum number of iterations to do before giving up. Because the"]
    #[doc = "                        maximum number of inputs (SECP256K1_SURJECTIONPROOF_MAX_N_INPUTS) is"]
    #[doc = "                        limited to 256 the probability of giving up is smaller than"]
    #[doc = "                        (255/256)^(n_input_tags_to_use*max_n_iterations)."]
    #[doc = ""]
    #[doc = "         random_seed32: a random seed to be used for input selection"]
    #[doc = " Out:            proof: The proof whose bitvector will be initialized. In case of failure,"]
    #[doc = "                        the state of the proof is undefined."]
    #[doc = "          input_index: The index of the actual input that is secretly mapped to the output"]
    pub fn secp256k1_zkp_surjectionproof_initialize(
        ctx: *const secp256k1_zkp_context,
        proof: *mut secp256k1_zkp_surjectionproof,
        input_index: *mut size_t,
        fixed_input_tags: *const secp256k1_zkp_fixed_asset_tag,
        n_input_tags: size_t,
        n_input_tags_to_use: size_t,
        fixed_output_tag: *const secp256k1_zkp_fixed_asset_tag,
        n_max_iterations: size_t,
        random_seed32: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Surjection proof allocation and initialization function; decides on inputs to use"]
    #[doc = " Returns 0: inputs could not be selected, or malloc failure"]
    #[doc = "         n: inputs were selected after n iterations of random selection"]
    #[doc = ""]
    #[doc = " In:               ctx: pointer to a context object"]
    #[doc = "           proof_out_p: a pointer to a pointer to `secp256k1_zkp_surjectionproof*`."]
    #[doc = "                        the newly-allocated struct pointer will be saved here."]
    #[doc = "      fixed_input_tags: fixed input tags `A_i` for all inputs. (If the fixed tag is not known,"]
    #[doc = "                        e.g. in a coinjoin with others' inputs, an ephemeral tag can be given;"]
    #[doc = "                        this won't match the output tag but might be used in the anonymity set.)"]
    #[doc = "          n_input_tags: the number of entries in the fixed_input_tags array"]
    #[doc = "      n_input_tags_to_use: the number of inputs to select randomly to put in the anonymity set"]
    #[doc = "      fixed_output_tag: fixed output tag"]
    #[doc = "      max_n_iterations: the maximum number of iterations to do before giving up. Because the"]
    #[doc = "                        maximum number of inputs (SECP256K1_SURJECTIONPROOF_MAX_N_INPUTS) is"]
    #[doc = "                        limited to 256 the probability of giving up is smaller than"]
    #[doc = "                        (255/256)^(n_input_tags_to_use*max_n_iterations)."]
    #[doc = ""]
    #[doc = "         random_seed32: a random seed to be used for input selection"]
    #[doc = " Out:      proof_out_p: The pointer to newly-allocated proof whose bitvector will be initialized."]
    #[doc = "                        In case of failure, the pointer will be NULL."]
    #[doc = "          input_index: The index of the actual input that is secretly mapped to the output"]
    pub fn secp256k1_zkp_surjectionproof_allocate_initialized(
        ctx: *const secp256k1_zkp_context,
        proof_out_p: *mut *mut secp256k1_zkp_surjectionproof,
        input_index: *mut size_t,
        fixed_input_tags: *const secp256k1_zkp_fixed_asset_tag,
        n_input_tags: size_t,
        n_input_tags_to_use: size_t,
        fixed_output_tag: *const secp256k1_zkp_fixed_asset_tag,
        n_max_iterations: size_t,
        random_seed32: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Surjection proof destroy function"]
    #[doc = "  deallocates the struct that was allocated with secp256k1_zkp_surjectionproof_allocate_initialized"]
    #[doc = ""]
    #[doc = " In:               proof: pointer to secp256k1_zkp_surjectionproof struct"]
    pub fn secp256k1_zkp_surjectionproof_destroy(proof: *mut secp256k1_zkp_surjectionproof);
}
extern "C" {
    #[doc = " Surjection proof generation function"]
    #[doc = " Returns 0: proof could not be created"]
    #[doc = "         1: proof was successfully created"]
    #[doc = ""]
    #[doc = " In:                   ctx: pointer to a context object, initialized for signing and verification"]
    #[doc = "      ephemeral_input_tags: the ephemeral asset tag of all inputs"]
    #[doc = "    n_ephemeral_input_tags: the number of entries in the ephemeral_input_tags array"]
    #[doc = "      ephemeral_output_tag: the ephemeral asset tag of the output"]
    #[doc = "               input_index: the index of the input that actually maps to the output"]
    #[doc = "        input_blinding_key: the blinding key of the input"]
    #[doc = "       output_blinding_key: the blinding key of the output"]
    #[doc = " In/Out: proof: The produced surjection proof. Must have already gone through `secp256k1_zkp_surjectionproof_initialize`"]
    pub fn secp256k1_zkp_surjectionproof_generate(
        ctx: *const secp256k1_zkp_context,
        proof: *mut secp256k1_zkp_surjectionproof,
        ephemeral_input_tags: *const secp256k1_zkp_generator,
        n_ephemeral_input_tags: size_t,
        ephemeral_output_tag: *const secp256k1_zkp_generator,
        input_index: size_t,
        input_blinding_key: *const ::std::os::raw::c_uchar,
        output_blinding_key: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Surjection proof verification function"]
    #[doc = " Returns 0: proof was invalid"]
    #[doc = "         1: proof was valid"]
    #[doc = ""]
    #[doc = " In:     ctx: pointer to a context object, initialized for signing and verification"]
    #[doc = "         proof: proof to be verified"]
    #[doc = "      ephemeral_input_tags: the ephemeral asset tag of all inputs"]
    #[doc = "    n_ephemeral_input_tags: the number of entries in the ephemeral_input_tags array"]
    #[doc = "      ephemeral_output_tag: the ephemeral asset tag of the output"]
    pub fn secp256k1_zkp_surjectionproof_verify(
        ctx: *const secp256k1_zkp_context,
        proof: *const secp256k1_zkp_surjectionproof,
        ephemeral_input_tags: *const secp256k1_zkp_generator,
        n_ephemeral_input_tags: size_t,
        ephemeral_output_tag: *const secp256k1_zkp_generator,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Opaque data structure that holds a parsed whitelist proof"]
#[doc = ""]
#[doc = "  The exact representation of data inside is implementation defined and not"]
#[doc = "  guaranteed to be portable between different platforms or versions. Nor is"]
#[doc = "  it guaranteed to have any particular size, nor that identical signatures"]
#[doc = "  will have identical representation. (That is, memcmp may return nonzero"]
#[doc = "  even for identical signatures.)"]
#[doc = ""]
#[doc = "  To obtain these properties, instead use secp256k1_zkp_whitelist_signature_parse"]
#[doc = "  and secp256k1_zkp_whitelist_signature_serialize to encode/decode signatures"]
#[doc = "  into a well-defined format."]
#[doc = ""]
#[doc = "  The representation is exposed to allow creation of these objects on the"]
#[doc = "  stack; please *do not* use these internals directly. To learn the number"]
#[doc = "  of keys for a signature, use `secp256k1_zkp_whitelist_signature_n_keys`."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct secp256k1_zkp_whitelist_signature {
    pub n_keys: size_t,
    pub data: [::std::os::raw::c_uchar; 8224usize],
}
#[test]
fn bindgen_test_layout_secp256k1_zkp_whitelist_signature() {
    assert_eq!(
        ::std::mem::size_of::<secp256k1_zkp_whitelist_signature>(),
        8232usize,
        concat!("Size of: ", stringify!(secp256k1_zkp_whitelist_signature))
    );
    assert_eq!(
        ::std::mem::align_of::<secp256k1_zkp_whitelist_signature>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(secp256k1_zkp_whitelist_signature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_whitelist_signature>())).n_keys as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_whitelist_signature),
            "::",
            stringify!(n_keys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<secp256k1_zkp_whitelist_signature>())).data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(secp256k1_zkp_whitelist_signature),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Parse a whitelist signature"]
    #[doc = ""]
    #[doc = "  Returns: 1 when the signature could be parsed, 0 otherwise."]
    #[doc = "  Args: ctx:    a secp256k1 context object"]
    #[doc = "  Out:  sig:    a pointer to a signature object"]
    #[doc = "  In:   input:  a pointer to the array to parse"]
    #[doc = "    input_len:  the length of the above array"]
    #[doc = ""]
    #[doc = "  The signature must consist of a 1-byte n_keys value, followed by a 32-byte"]
    #[doc = "  big endian e0 value, followed by n_keys many 32-byte big endian s values."]
    #[doc = "  If n_keys falls outside of [0..SECP256K1_WHITELIST_MAX_N_KEYS] the encoding"]
    #[doc = "  is invalid."]
    #[doc = ""]
    #[doc = "  The total length of the input array must therefore be 33 + 32 * n_keys."]
    #[doc = "  If the length `input_len` does not match this value, parsing will fail."]
    #[doc = ""]
    #[doc = "  After the call, sig will always be initialized. If parsing failed or any"]
    #[doc = "  scalar values overflow or are zero, the resulting sig value is guaranteed"]
    #[doc = "  to fail validation for any set of keys."]
    pub fn secp256k1_zkp_whitelist_signature_parse(
        ctx: *const secp256k1_zkp_context,
        sig: *mut secp256k1_zkp_whitelist_signature,
        input: *const ::std::os::raw::c_uchar,
        input_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of keys a signature expects to have."]
    #[doc = ""]
    #[doc = "  Returns: the number of keys for the given signature"]
    #[doc = "  In: sig: a pointer to a signature object"]
    pub fn secp256k1_zkp_whitelist_signature_n_keys(
        sig: *const secp256k1_zkp_whitelist_signature,
    ) -> size_t;
}
extern "C" {
    #[doc = " Serialize a whitelist signature"]
    #[doc = ""]
    #[doc = "  Returns: 1"]
    #[doc = "  Args:   ctx:        a secp256k1 context object"]
    #[doc = "  Out:    output64:   a pointer to an array to store the serialization"]
    #[doc = "  In/Out: output_len: length of the above array, updated with the actual serialized length"]
    #[doc = "  In:     sig:        a pointer to an initialized signature object"]
    #[doc = ""]
    #[doc = "  See secp256k1_zkp_whitelist_signature_parse for details about the encoding."]
    pub fn secp256k1_zkp_whitelist_signature_serialize(
        ctx: *const secp256k1_zkp_context,
        output: *mut ::std::os::raw::c_uchar,
        output_len: *mut size_t,
        sig: *const secp256k1_zkp_whitelist_signature,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compute a whitelist signature"]
    #[doc = " Returns 1: signature was successfully created"]
    #[doc = "         0: signature was not successfully created"]
    #[doc = " In:     ctx: pointer to a context object, initialized for signing and verification"]
    #[doc = "         online_pubkeys: list of all online pubkeys"]
    #[doc = "         offline_pubkeys: list of all offline pubkeys"]
    #[doc = "         n_keys: the number of entries in each of the above two arrays"]
    #[doc = "         sub_pubkey: the key to be whitelisted"]
    #[doc = "         online_seckey: the secret key to the signer's online pubkey"]
    #[doc = "         summed_seckey: the secret key to the sum of (whitelisted key, signer's offline pubkey)"]
    #[doc = "         index: the signer's index in the lists of keys"]
    #[doc = "         noncefp:pointer to a nonce generation function. If NULL, secp256k1_zkp_nonce_function_default is used"]
    #[doc = "         ndata:  pointer to arbitrary data used by the nonce generation function (can be NULL)"]
    #[doc = " Out:    sig: The produced signature."]
    #[doc = ""]
    #[doc = " The signatures are of the list of all passed pubkeys in the order"]
    #[doc = "     ( whitelist, online_1, offline_1, online_2, offline_2, ... )"]
    #[doc = " The verification key list consists of"]
    #[doc = "     online_i + H(offline_i + whitelist)(offline_i + whitelist)"]
    #[doc = " for each public key pair (offline_i, offline_i). Here H means sha256 of the"]
    #[doc = " compressed serialization of the key."]
    pub fn secp256k1_zkp_whitelist_sign(
        ctx: *const secp256k1_zkp_context,
        sig: *mut secp256k1_zkp_whitelist_signature,
        online_pubkeys: *const secp256k1_zkp_pubkey,
        offline_pubkeys: *const secp256k1_zkp_pubkey,
        n_keys: size_t,
        sub_pubkey: *const secp256k1_zkp_pubkey,
        online_seckey: *const ::std::os::raw::c_uchar,
        summed_seckey: *const ::std::os::raw::c_uchar,
        index: size_t,
        noncefp: secp256k1_zkp_nonce_function,
        noncedata: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Verify a whitelist signature"]
    #[doc = " Returns 1: signature is valid"]
    #[doc = "         0: signature is not valid"]
    #[doc = " In:     ctx: pointer to a context object, initialized for signing and verification"]
    #[doc = "         sig: the signature to be verified"]
    #[doc = "         online_pubkeys: list of all online pubkeys"]
    #[doc = "         offline_pubkeys: list of all offline pubkeys"]
    #[doc = "         n_keys: the number of entries in each of the above two arrays"]
    #[doc = "         sub_pubkey: the key to be whitelisted"]
    pub fn secp256k1_zkp_whitelist_verify(
        ctx: *const secp256k1_zkp_context,
        sig: *const secp256k1_zkp_whitelist_signature,
        online_pubkeys: *const secp256k1_zkp_pubkey,
        offline_pubkeys: *const secp256k1_zkp_pubkey,
        n_keys: size_t,
        sub_pubkey: *const secp256k1_zkp_pubkey,
    ) -> ::std::os::raw::c_int;
}
